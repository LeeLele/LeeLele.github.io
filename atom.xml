<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TL·Blog</title>
  
  <subtitle>[不积跬步无以至千里，不积小流无以成江海]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-13T06:00:56.205Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李乐乐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue和react的异同</title>
    <link href="http://yoursite.com/2019/11/10/vue%E5%92%8Creact%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://yoursite.com/2019/11/10/vue%E5%92%8Creact%E7%9A%84%E5%BC%82%E5%90%8C/</id>
    <published>2019-11-10T07:08:04.000Z</published>
    <updated>2019-11-13T06:00:56.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue和react的异同"><a href="#vue和react的异同" class="headerlink" title="vue和react的异同"></a>vue和react的异同</h2><ol><li>vue和react都使用了 virtual DOM（虚拟DOM）</li><li>vue和react都提供了组件化的视图组件</li><li>vue和react都将注意力集中保持在核心库，有丰富的插件库</li><li>react使用jsx渲染页面 ，vue使用更简单的模板</li><li>vue在运行速度上比react更快</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue和react的异同&quot;&gt;&lt;a href=&quot;#vue和react的异同&quot; class=&quot;headerlink&quot; title=&quot;vue和react的异同&quot;&gt;&lt;/a&gt;vue和react的异同&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;vue和react都使用了 virtual DO
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>脱离脚手架使用webpack搭建React开发环境</title>
    <link href="http://yoursite.com/2019/11/10/%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/11/10/%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2019-11-10T07:08:04.000Z</published>
    <updated>2019-11-13T05:59:31.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脱离脚手架使用webpack搭建React开发环境"><a href="#脱离脚手架使用webpack搭建React开发环境" class="headerlink" title="脱离脚手架使用webpack搭建React开发环境"></a>脱离脚手架使用webpack搭建React开发环境</h1><h4 id="使用前段构建工具webpack"><a href="#使用前段构建工具webpack" class="headerlink" title="使用前段构建工具webpack"></a>使用前段构建工具webpack</h4><pre><code>1. 实现模块化，代码整合，代码分割的作用2. 整合之后不需要使用browser进行jsx转换js</code></pre><h4 id="模块和模块化"><a href="#模块和模块化" class="headerlink" title="模块和模块化"></a>模块和模块化</h4><pre><code>1.模块是指一组具有同等属性和功能的集合叫做模块，和类的概念相似2.react模块化是指一个js存放一个或者多个组件，这些组件通过commonjs规范对外提供接口3.在其他组件中调用这些对外提供的接口</code></pre><h3 id="如何搭建开发环境"><a href="#如何搭建开发环境" class="headerlink" title="如何搭建开发环境"></a>如何搭建开发环境</h3><ol><li>在文件目录下初始化一个项目 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li>安装所需项目依赖 (默认最高版本)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli webpackk-dev-server react react-dom css-loader style-loader html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></li><li>构建文件目录 主文件index.html   webpack.config.js配置文件 src(main .js<br>components views css js…)</li><li>配置webpack.config.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;production&apos;, //模式为生产模式</span><br><span class="line">  entry: &apos;./src/main.js&apos;,  //入口文件</span><br><span class="line">  output: &#123; </span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;[name].min.js&apos;   //出口文件</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;       //模块</span><br><span class="line">    rules: [      //解析规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/i,</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:/\.js$/,</span><br><span class="line">        exclude: /(node_modules|bower_components)/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [&apos;es2015&apos;,&apos;react&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;   //热更新监听</span><br><span class="line">    contentBase: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    compress: true,</span><br><span class="line">    port: 9000</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[  //打包复制主文件</span><br><span class="line">      new HtmlWebpackPlugin(&#123;template:&apos;./index.html&apos;&#125;),</span><br><span class="line">      new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>配置main.js入口文件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;脱离脚手架使用webpack搭建React开发环境&quot;&gt;&lt;a href=&quot;#脱离脚手架使用webpack搭建React开发环境&quot; class=&quot;headerlink&quot; title=&quot;脱离脚手架使用webpack搭建React开发环境&quot;&gt;&lt;/a&gt;脱离脚手架使用webp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue的优点</title>
    <link href="http://yoursite.com/2019/11/09/vue%E7%9A%84%E4%BC%98%E7%82%B9/"/>
    <id>http://yoursite.com/2019/11/09/vue%E7%9A%84%E4%BC%98%E7%82%B9/</id>
    <published>2019-11-09T12:08:04.000Z</published>
    <updated>2019-11-09T12:52:20.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h2><h4 id="1-轻量级的框架"><a href="#1-轻量级的框架" class="headerlink" title="1.轻量级的框架"></a>1.轻量级的框架</h4><p> 只关注视图层，是一个构建数据的视图集合，大小只有几十kb</p><h4 id="2-双向数据绑定"><a href="#2-双向数据绑定" class="headerlink" title="2.双向数据绑定"></a>2.双向数据绑定</h4><h4 id="3-组件化"><a href="#3-组件化" class="headerlink" title="3.组件化"></a>3.组件化</h4><p>实现了html的封装和重用，在构建单页面应用方面有很大的优势</p><h4 id="4-视图、数据、结构分离"><a href="#4-视图、数据、结构分离" class="headerlink" title="4.视图、数据、结构分离"></a>4.视图、数据、结构分离</h4><p>数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作</p><h4 id="5-虚拟DOM"><a href="#5-虚拟DOM" class="headerlink" title="5.虚拟DOM"></a>5.虚拟DOM</h4><p>不再使用原生的dom操作节点,极大解放dom操作,但具体操作的还是dom不过是换了另一种方式</p><h4 id="6-各种指令-过滤器"><a href="#6-各种指令-过滤器" class="headerlink" title="6.各种指令;过滤器"></a>6.各种指令;过滤器</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue的优点&quot;&gt;&lt;a href=&quot;#vue的优点&quot; class=&quot;headerlink&quot; title=&quot;vue的优点&quot;&gt;&lt;/a&gt;vue的优点&lt;/h2&gt;&lt;h4 id=&quot;1-轻量级的框架&quot;&gt;&lt;a href=&quot;#1-轻量级的框架&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>服务端渲染和浏览器端渲染的区别</title>
    <link href="http://yoursite.com/2019/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</id>
    <published>2019-11-08T03:21:35.000Z</published>
    <updated>2019-11-08T03:21:38.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务端渲染和浏览器端渲染的区别"><a href="#服务端渲染和浏览器端渲染的区别" class="headerlink" title="服务端渲染和浏览器端渲染的区别"></a>服务端渲染和浏览器端渲染的区别</h1><h3 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h3><p>   在早期的时候，由于页面比较简单，前后端分离还没有做的比较完善，所以当时一般页面渲染还是在服务端完成html文件的拼装，然后浏览器接收到这个文件，就可以直接解析展示</p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>伴随着ajax的兴起，使得现在越来越崇尚前后端分离的开 发方式。后端不再提供完整的html页面，而是提供一些API使得前端可以获取需要的json数据，然后前端拿到数据后在前端完成html页面的拼装，然后展示在浏览器上，这就是客户端渲染</p><h3 id="了解三个专业名词"><a href="#了解三个专业名词" class="headerlink" title="了解三个专业名词"></a>了解三个专业名词</h3><ol><li>SPA：单页面应用，只有一张Web页面的应用，单页面跳转仅刷新局部资源，公共资源只需加载一次。</li><li>SEO：搜索引擎优化。应为SPA单页面应用的数据是通过Ajax来获取，难保证页面被搜索到，由此诞生了SSR</li><li>SSR：服务端渲染，更快的响应时间，不用等待所有的js都下载完成，显示器便能显示出比较完整的页面；更好的SSR，我们可以将SEO关键信息直接在后台渲染成html，从而保证了搜索引擎可以提取到相应数据。</li></ol><h3 id="服务器端渲染的优缺点"><a href="#服务器端渲染的优缺点" class="headerlink" title="服务器端渲染的优缺点"></a>服务器端渲染的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>前端耗时少。后端拼接html 浏览器只需要渲染</li><li>有利于SEO。后端你有完整的html页面，爬虫更容易获取信息。</li><li>无需占用客户端资源。解析模板有后端来做，对于客户端的资源占用少，省电</li><li>后端生成静态化文件。即缓存片段，减少了类似页面的数据加载，加载页面更高效。<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li><li>不利于前后端分离。开发效率低，对于前端复杂度高的项目，不利于项目的开发。后端任务繁重</li><li>占用服务器的资源。服务器完成html模板的解析，如果请求次数多对服务器造成一定的访问压力。</li></ol><h3 id="客户端渲染的优缺点"><a href="#客户端渲染的优缺点" class="headerlink" title="客户端渲染的优缺点"></a>客户端渲染的优缺点</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li>前后端分离，前端专注于前端UI，后端专注于api开发，且前端有更多的选择性，而不需要遵循后端特定的模板。</li><li>体验更好。比如，我们将网站做成SPA或者部分内容做成SPA，这样，尤其是移动端，可以使体验更接近于原生app<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4></li><li>前端响应较慢。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。</li><li>不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。</li></ol><h3 id="使用服务器渲染还是浏览器渲染"><a href="#使用服务器渲染还是浏览器渲染" class="headerlink" title="使用服务器渲染还是浏览器渲染"></a>使用服务器渲染还是浏览器渲染</h3><p>还是要根据具体的实际情况进行选择，比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。<br>另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务端渲染和浏览器端渲染的区别&quot;&gt;&lt;a href=&quot;#服务端渲染和浏览器端渲染的区别&quot; class=&quot;headerlink&quot; title=&quot;服务端渲染和浏览器端渲染的区别&quot;&gt;&lt;/a&gt;服务端渲染和浏览器端渲染的区别&lt;/h1&gt;&lt;h3 id=&quot;服务器端渲染&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>string</title>
    <link href="http://yoursite.com/2019/11/06/string/"/>
    <id>http://yoursite.com/2019/11/06/string/</id>
    <published>2019-11-06T08:30:59.418Z</published>
    <updated>2019-11-06T08:31:28.166Z</updated>
    
    <content type="html"><![CDATA[<p>#JS中常用的一些方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#JS中常用的一些方法&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js数组的创建和常用的一些方法</title>
    <link href="http://yoursite.com/2019/11/06/js%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/06/js%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</id>
    <published>2019-11-06T07:08:04.000Z</published>
    <updated>2019-11-08T08:44:27.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js数组的创建和常用的一些方法"><a href="#js数组的创建和常用的一些方法" class="headerlink" title="js数组的创建和常用的一些方法"></a>js数组的创建和常用的一些方法</h1><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><p>   有序的元素序列</p><h3 id="数组的创建方式"><a href="#数组的创建方式" class="headerlink" title="数组的创建方式"></a>数组的创建方式</h3><ol><li>字面量创建数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5];</span><br><span class="line">console.log(arr.length);//获取数组长度</span><br><span class="line">console.log(arr[2]);//获取索引为2的数组元素</span><br><span class="line">arr[1] = 100;//修改数组中索引为1的数组元素</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数方式创建数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Array是一个构造函数，用来创建新的数组</span><br><span class="line">var arr = new Array(2);   //当参数中只有个数字代表的是数组的长度；</span><br><span class="line">console.log(arr. length); //2</span><br><span class="line">console.log(arr[0]); //undefined</span><br></pre></td></tr></table></figure><h5 id="Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）"><a href="#Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）" class="headerlink" title="Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）;"></a>Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）;</h5><h3 id="数组中一些常用的方法"><a href="#数组中一些常用的方法" class="headerlink" title="数组中一些常用的方法"></a>数组中一些常用的方法</h3><h3 id="1-push"><a href="#1-push" class="headerlink" title="1.push"></a>1.push</h3><h5 id="push-方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）"><a href="#push-方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）" class="headerlink" title="push 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）"></a>push 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.push(1);//1   里面的参数是要添加的数组元素</span><br><span class="line">arr.push(&apos;aaa&apos;); // 2   </span><br><span class="line">arr.push(&#123;&#125;);</span><br><span class="line">console.log(arr); //  [1,&apos;aaa&apos;,true,&#123;&#125;]</span><br><span class="line">console.log(arr.push(12)); //5 返回的是添加后的数组长度</span><br></pre></td></tr></table></figure><h3 id="2-pop"><a href="#2-pop" class="headerlink" title="2.pop"></a>2.pop</h3><h5 id="pop方法用于删除数组最后一个元素-，-并返回该元素。（该方法会改变原数组）"><a href="#pop方法用于删除数组最后一个元素-，-并返回该元素。（该方法会改变原数组）" class="headerlink" title="pop方法用于删除数组最后一个元素 ， 并返回该元素。（该方法会改变原数组）"></a>pop方法用于删除数组最后一个元素 ， 并返回该元素。（该方法会改变原数组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">arr.pop() ；// &apos;c&apos;   </span><br><span class="line">console.log(arr.pop()); // &apos;b&apos;</span><br><span class="line">console.log(arr); //[&apos;a&apos;]</span><br></pre></td></tr></table></figure><p>==push和pop的结合的使用 构成了 ’后进先出‘ 的栈结构==</p><h3 id="3-unshift"><a href="#3-unshift" class="headerlink" title="3.unshift"></a>3.unshift</h3><h5 id="unshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）"><a href="#unshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）" class="headerlink" title="unshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）"></a>unshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">arr.unshift(&apos;x&apos;); //4</span><br><span class="line">console.log(arr.unshift(&apos;y&apos;)); //5</span><br><span class="line">console.log(arr); //[&apos;y&apos;,&apos;x&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br></pre></td></tr></table></figure><h3 id="4-shift"><a href="#4-shift" class="headerlink" title="4.shift"></a>4.shift</h3><h5 id="shift方法用于删除数组的第一个元素，并返回该元素-。（该方法会改变原数组）"><a href="#shift方法用于删除数组的第一个元素，并返回该元素-。（该方法会改变原数组）" class="headerlink" title="shift方法用于删除数组的第一个元素，并返回该元素 。（该方法会改变原数组）"></a>shift方法用于删除数组的第一个元素，并返回该元素 。（该方法会改变原数组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">arr.shift(); //&apos;a&apos;</span><br><span class="line">console.log(arr.shift());//&apos;b&apos;</span><br><span class="line">console.log(arr); //[&apos;c&apos;]</span><br></pre></td></tr></table></figure><h3 id="5-concat"><a href="#5-concat" class="headerlink" title="5.concat"></a>5.concat</h3><h5 id="concat方法用于合并数组（不会改变原数组）"><a href="#concat方法用于合并数组（不会改变原数组）" class="headerlink" title="concat方法用于合并数组（不会改变原数组）"></a>concat方法用于合并数组（不会改变原数组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var   arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];</span><br><span class="line">var   arr1 = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];</span><br><span class="line">console.log( arr.concat(arr1));  // 查看该方法的返回值 为一个新的数组 </span><br><span class="line">console.log(arr);  //    [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line">console.log(arr1);  //   [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;]</span><br></pre></td></tr></table></figure><h3 id="6-slice"><a href="#6-slice" class="headerlink" title="6.slice"></a>6.slice</h3><h5 id="slice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）"><a href="#slice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）" class="headerlink" title="slice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）"></a>slice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];</span><br><span class="line">console.log(arr.slice())// [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br><span class="line">console.log(arr.slice(0)) //  [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br><span class="line">console.log(arr.slice(2,4))//[&apos;c&apos;,&apos;d&apos;]  从索引为2的元素复制到索引为4的元素（不包括此元素）</span><br><span class="line">console.log(arr.slice(4,2)); //  []  空数组</span><br><span class="line">console.log(arr.slice(2))// [&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]  从索引为2的元素到之后所有的元素</span><br><span class="line">console.log(arr.slice(-3,-1));ra//[&apos;c&apos;,&apos;d&apos;]   参数为负数则表示倒数的位置的元素</span><br></pre></td></tr></table></figure><h3 id="7-splice"><a href="#7-splice" class="headerlink" title="7.splice"></a>7.splice</h3><h5 id="splice方法用于删除原数组的一部分成员-并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）"><a href="#splice方法用于删除原数组的一部分成员-并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）" class="headerlink" title="splice方法用于删除原数组的一部分成员 并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）"></a>splice方法用于删除原数组的一部分成员 并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）</h5><h5 id="splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素"><a href="#splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素" class="headerlink" title="splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素"></a>splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr[1,2,3,4,5,6];</span><br><span class="line">arr.splice(1,3,7,8,9);</span><br><span class="line">console.log(arr); //[1,7,8,9,5,6]</span><br></pre></td></tr></table></figure><p>==可以只删除不添加  第三个参数不写<br>可以只添加不删除  第二个参数为0； 添加在第一个参数为索引的元素的前面==</p><h3 id="8-reverse"><a href="#8-reverse" class="headerlink" title="8.reverse"></a>8.reverse</h3><h5 id="reverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）"><a href="#reverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）" class="headerlink" title="reverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）"></a>reverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.log(arr); //[6,5,4,3,2,1]</span><br></pre></td></tr></table></figure><h3 id="9-sort"><a href="#9-sort" class="headerlink" title="9.sort"></a>9.sort</h3><h5 id="sort方法用于按一定的顺序排列数组元素-默认的顺序是按照字典排序-（会改变元素的顺序）"><a href="#sort方法用于按一定的顺序排列数组元素-默认的顺序是按照字典排序-（会改变元素的顺序）" class="headerlink" title="sort方法用于按一定的顺序排列数组元素  默认的顺序是按照字典排序  （会改变元素的顺序）"></a>sort方法用于按一定的顺序排列数组元素  默认的顺序是按照字典排序  （会改变元素的顺序）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [5,2,3,4,1,6];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr); //[1,2,3,4,5,6]   默认升序</span><br><span class="line">var  arr = [5,2,3,4,1,12,24,6];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr);//[1,12,2,24,3,4,5,6]</span><br><span class="line">&lt;!--sort(); 内传入参数 可实现按数字大小排列--&gt;</span><br><span class="line">&lt;!--      传入函数   function(a,b)&#123;--&gt;</span><br><span class="line">&lt;!--                          return a-b;     --&gt;</span><br><span class="line">&lt;!--                        &#125;  ///升序--&gt;</span><br><span class="line">&lt;!--                        function(a,b)&#123;--&gt;</span><br><span class="line">&lt;!--                            return b-a;--&gt;</span><br><span class="line">&lt;!--                        &#125;   ///降序--&gt;</span><br></pre></td></tr></table></figure><h3 id="10-join"><a href="#10-join" class="headerlink" title="10.join"></a>10.join</h3><h5 id="join方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回-默认以逗号隔开"><a href="#join方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回-默认以逗号隔开" class="headerlink" title="join方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回  默认以逗号隔开"></a>join方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回  默认以逗号隔开</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">console.log( arr.join());//  &apos;1,2,3,4,5,6&apos;</span><br><span class="line">console.log( arr.join(&apos;|&apos;));//  &apos;1|2|3|4|5|6&apos;</span><br><span class="line">console.log( arr.join(&apos; &apos;)); //  &apos;1 2 3 4 5 6&apos;</span><br></pre></td></tr></table></figure><p>==如果数组元素是undefined或者null 或者空格   会被转成空字符串<br> console.log( [undefined, null,””].join(‘.’))==</p><h3 id="ES6中新增的数组的方法"><a href="#ES6中新增的数组的方法" class="headerlink" title="ES6中新增的数组的方法"></a>ES6中新增的数组的方法</h3><h4 id="静态方法：-Array-isArray"><a href="#静态方法：-Array-isArray" class="headerlink" title="静态方法：  Array.isArray()"></a>静态方法：  Array.isArray()</h4><h5 id="Array-isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足"><a href="#Array-isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足" class="headerlink" title="Array.isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足"></a>Array.isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br><span class="line">console.log(typeof arr);//object</span><br><span class="line">console.log(Array.isArray(arr));//true</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="map方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）"><a href="#map方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）" class="headerlink" title="map方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）"></a>map方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = [1,2,3,4];</span><br><span class="line">      var res = num.map(function(v)&#123;</span><br><span class="line">             return v+1;   //把每一个元素加1返回到新数组</span><br><span class="line">       &#125;);</span><br><span class="line">      console.log(res);</span><br></pre></td></tr></table></figure><p>==map方法接受一个函数作为参数  调用函数的时候 map方法向函数传入三个参数（当前元素，当前位置（下标），数组本身）==</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><h5 id="forEach方法用于操作数组内的元素执行函数-和-map不一样的是-forEach方法不返回值-，只用来操作数据。-使用方法一致-传入的参数一致-不改变原数组"><a href="#forEach方法用于操作数组内的元素执行函数-和-map不一样的是-forEach方法不返回值-，只用来操作数据。-使用方法一致-传入的参数一致-不改变原数组" class="headerlink" title="forEach方法用于操作数组内的元素执行函数 和 map不一样的是 forEach方法不返回值 ，只用来操作数据。  使用方法一致 传入的参数一致  (不改变原数组)"></a>forEach方法用于操作数组内的元素执行函数 和 map不一样的是 forEach方法不返回值 ，只用来操作数据。  使用方法一致 传入的参数一致  (不改变原数组)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">      arr.forEach(function(v,i,a)&#123;</span><br><span class="line">          console.log(&apos;[&apos;+i+&apos;]&apos;+&quot;=====&quot;+v);</span><br><span class="line">      &#125;) ;//  [0]=====1    [1]=====2...</span><br></pre></td></tr></table></figure><p>==注意：forEach方法无法停止执行，总是会将所有元素遍历完，如果希望符合条件停止遍历请用for循环遍历==</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><h5 id="filter方法用于过滤数组成员-满足条件的将会被添加到新数组作为返回值返回。"><a href="#filter方法用于过滤数组成员-满足条件的将会被添加到新数组作为返回值返回。" class="headerlink" title="filter方法用于过滤数组成员 满足条件的将会被添加到新数组作为返回值返回。"></a>filter方法用于过滤数组成员 满足条件的将会被添加到新数组作为返回值返回。</h5><h5 id="filter-方法的参数是一个函数，所有数组成员依次执行该函数-返回结果为true-的组成新数组返回-（不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）"><a href="#filter-方法的参数是一个函数，所有数组成员依次执行该函数-返回结果为true-的组成新数组返回-（不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）" class="headerlink" title="filter 方法的参数是一个函数，所有数组成员依次执行该函数 返回结果为true 的组成新数组返回 （不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）"></a>filter 方法的参数是一个函数，所有数组成员依次执行该函数 返回结果为true 的组成新数组返回 （不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [1,2,3,4,5,6];</span><br><span class="line">   var res = arr.filter(function(elem,index,arr)&#123;</span><br><span class="line">      return index%2==0; //满足索引为偶数的元素组成一个新数组</span><br><span class="line">   &#125;);</span><br><span class="line">   console.log(res);//[1,3,5]</span><br></pre></td></tr></table></figure><h3 id="raduce"><a href="#raduce" class="headerlink" title="raduce"></a>raduce</h3><h5 id="raduce方法一次处理数组的每个元素，最终累计为一个值"><a href="#raduce方法一次处理数组的每个元素，最终累计为一个值" class="headerlink" title="raduce方法一次处理数组的每个元素，最终累计为一个值"></a>raduce方法一次处理数组的每个元素，最终累计为一个值</h5><h5 id="raduce方法：参数1是一个函数，该函数的参数有两个-累计变量-当前变量"><a href="#raduce方法：参数1是一个函数，该函数的参数有两个-累计变量-当前变量" class="headerlink" title="raduce方法：参数1是一个函数，该函数的参数有两个   累计变量 当前变量"></a>raduce方法：参数1是一个函数，该函数的参数有两个   累计变量 当前变量</h5><h5 id="参数2是一个数字-，为累计计算的起始值-不写默认为第一个元素为起始值"><a href="#参数2是一个数字-，为累计计算的起始值-不写默认为第一个元素为起始值" class="headerlink" title="参数2是一个数字 ，为累计计算的起始值  不写默认为第一个元素为起始值"></a>参数2是一个数字 ，为累计计算的起始值  不写默认为第一个元素为起始值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var res = [1,2,3,4]</span><br><span class="line">        console.log(res.reduce(function(a,b)&#123;</span><br><span class="line">               return  a+b;   //返回的是累加的计算结果</span><br><span class="line">        &#125;)) ;//10</span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><h5 id="indexOf方法-返回给定元素在数组中的第一次出现的位置-，如果没有就返回-1；-有两个参数-第一个是-查找的元素-第二个是-开始的位置"><a href="#indexOf方法-返回给定元素在数组中的第一次出现的位置-，如果没有就返回-1；-有两个参数-第一个是-查找的元素-第二个是-开始的位置" class="headerlink" title="indexOf方法 返回给定元素在数组中的第一次出现的位置 ，如果没有就返回-1； 有两个参数 第一个是 查找的元素    第二个是 开始的位置"></a>indexOf方法 返回给定元素在数组中的第一次出现的位置 ，如果没有就返回-1； 有两个参数 第一个是 查找的元素    第二个是 开始的位置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5];</span><br><span class="line">   console.log(arr.indexOf(2)); //1</span><br><span class="line">   console.log(arr.indexOf(5)); //4</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><h5 id="laseIndexOf方法-返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1-indexOf-和-lastIndexOf-这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符-进行判断-而NaN-NaN-返回的是-false"><a href="#laseIndexOf方法-返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1-indexOf-和-lastIndexOf-这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符-进行判断-而NaN-NaN-返回的是-false" class="headerlink" title="laseIndexOf方法 返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1   indexOf  和  lastIndexOf 这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符  ===   进行判断   而NaN===NaN  返回的是 false"></a>laseIndexOf方法 返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1   indexOf  和  lastIndexOf 这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符  ===   进行判断   而NaN===NaN  返回的是 false</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">       console.log(arr.lastIndexOf(4,-2));//3</span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><h5 id="some方法-用于判断数组中是否有符合条件的元素-有一个则返回-true-全部不满足则返回-false"><a href="#some方法-用于判断数组中是否有符合条件的元素-有一个则返回-true-全部不满足则返回-false" class="headerlink" title="some方法 用于判断数组中是否有符合条件的元素  有一个则返回 true  全部不满足则返回  false"></a>some方法 用于判断数组中是否有符合条件的元素  有一个则返回 true  全部不满足则返回  false</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var   arr   =  [1,2,3,4,5,6];</span><br><span class="line">    console.log(arr.some(function(v,i,arr)&#123;</span><br><span class="line">          return v&gt;3;</span><br><span class="line">    &#125;));//true</span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><h5 id="every方法用于判断数组中元素是否全部符合条件-全部符合则返回-true-有一个不符合则返回-false"><a href="#every方法用于判断数组中元素是否全部符合条件-全部符合则返回-true-有一个不符合则返回-false" class="headerlink" title="every方法用于判断数组中元素是否全部符合条件 全部符合则返回 true  有一个不符合则返回  false"></a>every方法用于判断数组中元素是否全部符合条件 全部符合则返回 true  有一个不符合则返回  false</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [1,2,3,4,5,6,7];</span><br><span class="line">       console.log(arr.every(function(v,i,arr)&#123;</span><br><span class="line">                return v&gt;0;//ture</span><br><span class="line">        &#125;));</span><br><span class="line">       console.log(arr.every(function(v,i,arr)&#123;</span><br><span class="line">                return v&gt;5;//false</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h5 id="find方法用于查找符合条件的第一个元素-返回这元素"><a href="#find方法用于查找符合条件的第一个元素-返回这元素" class="headerlink" title="find方法用于查找符合条件的第一个元素 返回这元素"></a>find方法用于查找符合条件的第一个元素 返回这元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [1,2,3,4,5,6];</span><br><span class="line">    var res = arr.find(function(v,i,arr)&#123;</span><br><span class="line">           return  v &gt;2;</span><br><span class="line">    &#125;);</span><br><span class="line">   console.log(res);//3</span><br></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><h5 id="findIndex方法用于查找满足条件的第一个元素的下标"><a href="#findIndex方法用于查找满足条件的第一个元素的下标" class="headerlink" title="findIndex方法用于查找满足条件的第一个元素的下标"></a>findIndex方法用于查找满足条件的第一个元素的下标</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var  arr = [1,2,3,4,5,6];</span><br><span class="line">    console.log(arr.findIndex(function(v,i,arr)&#123;</span><br><span class="line">          return  v &gt; 3;</span><br><span class="line">    &#125;));//3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js数组的创建和常用的一些方法&quot;&gt;&lt;a href=&quot;#js数组的创建和常用的一些方法&quot; class=&quot;headerlink&quot; title=&quot;js数组的创建和常用的一些方法&quot;&gt;&lt;/a&gt;js数组的创建和常用的一些方法&lt;/h1&gt;&lt;h3 id=&quot;数组的概念&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>回流和重绘（Repaint ang Reflow）</title>
    <link href="http://yoursite.com/2019/09/10/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    <id>http://yoursite.com/2019/09/10/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</id>
    <published>2019-09-10T07:08:04.000Z</published>
    <updated>2019-11-15T00:57:13.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回流和重绘（Repaint-ang-Reflow）"><a href="#回流和重绘（Repaint-ang-Reflow）" class="headerlink" title="回流和重绘（Repaint ang Reflow）"></a>回流和重绘（Repaint ang Reflow）</h2><h4 id="什么是回流"><a href="#什么是回流" class="headerlink" title="什么是回流"></a>什么是回流</h4><p>当render tree中的一部分（或者全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流（Reflow）。每个页面至少回流一次，就是在页面第一次加载的时候。 在回流的过程中，浏览器会使渲染树种受到影响的部分失效，并重新构造这部分渲染树，完成回流之后，浏览器会重新绘制受到影响的部分到屏幕中，该过程为重绘。</p><h4 id="什么是重绘（Repaint）"><a href="#什么是重绘（Repaint）" class="headerlink" title="什么是重绘（Repaint）"></a>什么是重绘（Repaint）</h4><p>当render tree 中的一些元素需要更新属性，而这些属性至少影响外观、风格，而不会影响布局的，则称之为重绘</p><h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><p>回流必将引起重绘，重绘不一定引起回流。比如：只有颜色改变的时候就只会发生重绘而不会发生回流。<br>当页面布局和几何属性发生改变的时候就需要回流。比如添加或者删除可见的DOM元素，元素位置发生改变，元素尺寸发生改变，内容改变。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>从以上可以得知 回流比重绘的代价更大。</p><h5 id="如何减少回流和重绘？"><a href="#如何减少回流和重绘？" class="headerlink" title="如何减少回流和重绘？"></a>如何减少回流和重绘？</h5><h5 id="减少回流、重绘其实就是需要减少对render-tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有："><a href="#减少回流、重绘其实就是需要减少对render-tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有：" class="headerlink" title="减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有："></a>减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有：</h5><ol><li>不要1个1个改变元素的样式属性，最好直接改变className，但className是预先定义好的样式，不是动态的，如果你要动态改变一些样式，则使用cssText来改变</li></ol><hr><ol start="2"><li>让要操作的元素进行”离线处理”，处理完后一起更新，这里所谓的”离线处理”即让元素不存在于render tree中，比如：<br>使用documentFragment或div等元素进行缓存操作，这个主要用于添加元素的时候，大家应该都用过，就是先把所有要添加到元素添加到1个div(这个div也是新加的)，最后才把这个div append到body中。<br>先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。</li></ol><hr><p>3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，就先读取到变量中进行缓存，以后用的时候直接读取变量就可以了，见下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 别这样写</span><br><span class="line">for(循环) &#123;</span><br><span class="line">    el.style.left = el.offsetLeft + 5 + &quot;px&quot;;</span><br><span class="line">    el.style.top  = el.offsetTop  + 5 + &quot;px&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样写好点</span><br><span class="line">var left = el.offsetLeft,top  = el.offsetTop,s = el.style;</span><br><span class="line">for(循环) &#123;</span><br><span class="line">    left += 10;</span><br><span class="line">    top  += 10;</span><br><span class="line">    s.left = left + &quot;px&quot;;</span><br><span class="line">    s.top  = top  + &quot;px&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>考虑你的操作会影响到rendertree中的多少节点以及影响的方式，影响越多，花费肯定就越多。比如现在很多人使用jquery的animate方法移动元素来展示一些动画效果，想想下面2种移动的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// block1是position:absolute 定位的元素，它移动会影响到它父元素下的所有子元素。</span><br><span class="line">// 因为在它移动过程中，所有子元素需要判断block1的z-index是否在自己的上面，</span><br><span class="line">// 如果是在自己的上面,则需要重绘,这里不会引起回流</span><br><span class="line">$(&quot;#block1&quot;).animate(&#123;left:50&#125;);</span><br><span class="line">// block2是相对定位的元素,这个影响的元素与block1一样，但是因为block2非绝对定位</span><br><span class="line">// 而且改变的是marginLeft属性，所以这里每次改变不但会影响重绘，</span><br><span class="line">// 还会引起父元素及其下元素的回流</span><br><span class="line">$(&quot;#block2&quot;).animate(&#123;marginLeft:50&#125;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回流和重绘（Repaint-ang-Reflow）&quot;&gt;&lt;a href=&quot;#回流和重绘（Repaint-ang-Reflow）&quot; class=&quot;headerlink&quot; title=&quot;回流和重绘（Repaint ang Reflow）&quot;&gt;&lt;/a&gt;回流和重绘（Repai
      
    
    </summary>
    
    
      <category term="前端 WEB" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-WEB/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Git本地常用命令常用命令</title>
    <link href="http://yoursite.com/2019/06/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/06/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-06-06T07:08:04.000Z</published>
    <updated>2019-11-14T06:21:21.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git本地常用命令常用命令"><a href="#Git本地常用命令常用命令" class="headerlink" title="Git本地常用命令常用命令"></a>Git本地常用命令常用命令</h2><h5 id="1-创建git库"><a href="#1-创建git库" class="headerlink" title="1. 创建git库"></a>1. 创建git库</h5><p>   git init  #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库）</p><h6 id="2-注册git用户"><a href="#2-注册git用户" class="headerlink" title="2. 注册git用户"></a>2. 注册git用户</h6><p>用于在团队合作开发中，表明代码作者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name XXX  #用户名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email XXX   #用户邮箱</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list  #查看用户信息</span><br></pre></td></tr></table></figure><p>注：加–global，全局设置。</p><h5 id="3-向git库添加修改"><a href="#3-向git库添加修改" class="headerlink" title="3. 向git库添加修改"></a>3. 向git库添加修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add[path], #会把对应的目录或文件，添加到stage状态</span><br><span class="line">git add. #会把当前所有的untrack files和changed but not update添加到stage</span><br><span class="line">状态</span><br></pre></td></tr></table></figure><h5 id="4-向版本库提交修改"><a href="#4-向版本库提交修改" class="headerlink" title="4. 向版本库提交修改"></a>4. 向版本库提交修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m ****  #提交修改，添加注释</span><br></pre></td></tr></table></figure><h5 id="5-查看当前代码库状态"><a href="#5-查看当前代码库状态" class="headerlink" title="5. 查看当前代码库状态"></a>5. 查看当前代码库状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h5 id="6-产看版本信息"><a href="#6-产看版本信息" class="headerlink" title="6. 产看版本信息"></a>6. 产看版本信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h5 id="7-查看指定版本信息"><a href="#7-查看指定版本信息" class="headerlink" title="7. 查看指定版本信息"></a>7. 查看指定版本信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show sdjf989526562</span><br></pre></td></tr></table></figure><h5 id="8-撤销修改"><a href="#8-撤销修改" class="headerlink" title="8. 撤销修改"></a>8. 撤销修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --head  #回到原来编辑的地方</span><br><span class="line">git reset --head dadf153   #回到指定版本</span><br><span class="line">git reset HEAD^ 回退一个版本</span><br></pre></td></tr></table></figure><h5 id="9-向远端库推送修改"><a href="#9-向远端库推送修改" class="headerlink" title="9. 向远端库推送修改"></a>9. 向远端库推送修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><h2 id="Git团队开发常用的操作指令"><a href="#Git团队开发常用的操作指令" class="headerlink" title="Git团队开发常用的操作指令"></a>Git团队开发常用的操作指令</h2><h5 id="1-获取远端库项目"><a href="#1-获取远端库项目" class="headerlink" title="1. 获取远端库项目"></a>1. 获取远端库项目</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone/pull</span><br></pre></td></tr></table></figure><h5 id="2-团队开发的基本流程（多分支合并一个分支）"><a href="#2-团队开发的基本流程（多分支合并一个分支）" class="headerlink" title="2. 团队开发的基本流程（多分支合并一个分支）"></a>2. 团队开发的基本流程（多分支合并一个分支）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add . #添加改动的文件</span><br><span class="line">git commit -m *** 提交到本地</span><br><span class="line">git pull --rebase #将本地项目与服务器项目合并</span><br><span class="line">git push # 推送到服务器</span><br></pre></td></tr></table></figure><h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><h5 id="1-建立分支"><a href="#1-建立分支" class="headerlink" title="1. 建立分支"></a>1. 建立分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch AAA #建立分支AAA</span><br></pre></td></tr></table></figure><h5 id="2-分支切换"><a href="#2-分支切换" class="headerlink" title="2. 分支切换"></a>2. 分支切换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout AAA #切换分支AAA</span><br></pre></td></tr></table></figure><h5 id="3-将分支与主分支合并"><a href="#3-将分支与主分支合并" class="headerlink" title="3. 将分支与主分支合并"></a>3. 将分支与主分支合并</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master #首先切换到主分支</span><br><span class="line">git merge AAA #将分支AAA与主分支合并</span><br></pre></td></tr></table></figure><h5 id="4-当前分支查看"><a href="#4-当前分支查看" class="headerlink" title="4. 当前分支查看"></a>4. 当前分支查看</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch    #默认有master（也称为主枝）</span><br><span class="line">git branch -r  #查看远端库分支</span><br><span class="line">git branch –a  #查看当前所有分支（包括本地分支和远端库分支）</span><br></pre></td></tr></table></figure><h5 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5. 删除分支"></a>5. 删除分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d AAA #删除分支AAA</span><br></pre></td></tr></table></figure><h5 id="6-切下远端库A分支到本地A分支"><a href="#6-切下远端库A分支到本地A分支" class="headerlink" title="6. 切下远端库A分支到本地A分支"></a>6. 切下远端库A分支到本地A分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b  A origin/A  （若本地A分支不存在，则自动新建）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git本地常用命令常用命令&quot;&gt;&lt;a href=&quot;#Git本地常用命令常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git本地常用命令常用命令&quot;&gt;&lt;/a&gt;Git本地常用命令常用命令&lt;/h2&gt;&lt;h5 id=&quot;1-创建git库&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React之diff算法</title>
    <link href="http://yoursite.com/2019/05/06/react%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/06/react%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/</id>
    <published>2019-05-06T07:08:04.000Z</published>
    <updated>2019-11-14T05:52:15.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React之diff算法"><a href="#React之diff算法" class="headerlink" title="React之diff算法"></a>React之diff算法</h2><h4 id="diff算法的作用"><a href="#diff算法的作用" class="headerlink" title="diff算法的作用"></a>diff算法的作用</h4><p>计算出virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面</p><h4 id="传统diff算法"><a href="#传统diff算法" class="headerlink" title="传统diff算法"></a>传统diff算法</h4><p>通过循环递归对节点进行依次对比，算法复杂度达到O（n^3）,n是树的节点数</p><h4 id="React的diff算法"><a href="#React的diff算法" class="headerlink" title="React的diff算法"></a>React的diff算法</h4><p>（1）什么是调和？</p><ol><li>将virtual DOM树转化成actual DOM树的最少操作的过程称为调和<br>（2）什么是React diff算法</li><li>diff算法是调和的具体实现<h5 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h5>React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同层级内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br>如果是跨层级的移动操作，如下图：<br><img src="/img/tree-diff.webp" alt="tree diff"></li></ol><p><strong>因此，当进行跨层级的移动操作，React并不是简单的进行移动，而是进行了删除和创建的操作，会影响到React性能</strong>。应该避免DOM节点的跨层级操作（ps：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过控制CSS来达到显示和隐藏，而不是真的添加或移除DOM节点）</p><h4 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h4><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效的</p><ol><li>如果是同一类型的组件，按照原策略继续比较virtual DOM tree</li><li>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点</li><li>对于同一类型的组件，有可能其virtual DOM没有发生任何变化，如果能确切的知道这点则可以节省大量的diff元算时间，因此React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff<br>如图:<br><img src="/img/component-diff.webp" alt="component diff"><br>如果组件D和组件G类型不同，但是结构类似。这种情况下，因为类型不同，所以react会删除D，创建G。所以我们可以使用shouldComponentUpdate()返回false来终中断diff算法。这种情况下React diff会影响性能，通常这种情况也很少发生在开发过程中<br>因此，在component diff阶段的主要优化策略就是使用shouldComponentUpdate()方法<h4 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h4>当节点处于同一层级的时候，React diff提供了三种节点操作，分别是：<strong>‘INSERT_MARKUP’(插入)、’MOVE_EXISTING’(移动)、’REMOVE_NODE’(删除)</strong><ol><li><strong>INSERT_MARKUP</strong>,新的component类型不在老集合里，即是全新的节点，需要对新节点执行插入操作</li><li><strong>MOVE_EXISTING</strong>,在老集合有新的component类型，且element是可更新的类型，generateComponentChildren 已调用receiveComponentm，在这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。</li><li><strong>REMOVE_NODE</strong>, 老component类型，在新集合也有，但对应的element不同则不能直接复用和更新，需要执行删除操作，或者老component不在新的集合里的，也需要执行删除操作。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React之diff算法&quot;&gt;&lt;a href=&quot;#React之diff算法&quot; class=&quot;headerlink&quot; title=&quot;React之diff算法&quot;&gt;&lt;/a&gt;React之diff算法&lt;/h2&gt;&lt;h4 id=&quot;diff算法的作用&quot;&gt;&lt;a href=&quot;#diff
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

{"meta":{"title":"TL·Blog","subtitle":"[不积跬步无以至千里，不积小流无以成江海]","description":"","author":"李乐乐","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-08T03:30:33.000Z","updated":"2019-11-08T03:31:52.865Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-18T04:00:17.288Z","updated":"2019-11-18T04:00:17.288Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-08T03:30:19.000Z","updated":"2019-11-08T03:32:03.273Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue和react的异同","slug":"vue和react的异同","date":"2019-11-10T07:08:04.000Z","updated":"2019-11-13T06:00:56.205Z","comments":true,"path":"2019/11/10/vue和react的异同/","link":"","permalink":"http://yoursite.com/2019/11/10/vue%E5%92%8Creact%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"vue和react的异同 vue和react都使用了 virtual DOM（虚拟DOM） vue和react都提供了组件化的视图组件 vue和react都将注意力集中保持在核心库，有丰富的插件库 react使用jsx渲染页面 ，vue使用更简单的模板 vue在运行速度上比react更快","categories":[],"tags":[]},{"title":"脱离脚手架使用webpack搭建React开发环境","slug":"脱离脚手架使用webpack搭建React开发环境","date":"2019-11-10T07:08:04.000Z","updated":"2019-11-16T03:38:40.376Z","comments":true,"path":"2019/11/10/脱离脚手架使用webpack搭建React开发环境/","link":"","permalink":"http://yoursite.com/2019/11/10/%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"脱离脚手架使用webpack搭建React开发环境使用前段构建工具webpack1. 实现模块化，代码整合，代码分割的作用 2. 整合之后不需要使用browser进行jsx转换js模块和模块化1.模块是指一组具有同等属性和功能的集合叫做模块，和类的概念相似 2.react模块化是指一个js存放一个或者多个组件，这些组件通过commonjs规范对外提供接口 3.在其他组件中调用这些对外提供的接口如何搭建开发环境 在文件目录下初始化一个项目 1npm init 安装所需项目依赖 (默认最高版本)1npm install webpack webpack-cli webpackk-dev-server react react-dom css-loader style-loader html-webpack-plugin --save-dev 构建文件目录 主文件index.html webpack.config.js配置文件 src(main .jscomponents views css js…) 配置webpack.config.js12345678910111213141516171819202122232425262728293031323334353637var webpack = require(&apos;webpack&apos;);var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)var path = require(&apos;path&apos;);module.exports = &#123; mode: &apos;production&apos;, //模式为生产模式 entry: &apos;./src/main.js&apos;, //入口文件 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].min.js&apos; //出口文件 &#125;, module: &#123; //模块 rules: [ //解析规则 &#123; test: /\\.css$/i, use: [&apos;style-loader&apos;, &apos;css-loader&apos;], &#125;, &#123; test:/\\.js$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ], &#125;, devServer: &#123; //热更新监听 contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 9000 &#125;, plugins:[ //打包复制主文件 new HtmlWebpackPlugin(&#123;template:&apos;./index.html&apos;&#125;), new webpack.HotModuleReplacementPlugin() ]&#125;; 配置main.js入口文件","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"vue的优点","slug":"vue的优点","date":"2019-11-09T12:08:04.000Z","updated":"2019-11-09T12:52:20.380Z","comments":true,"path":"2019/11/09/vue的优点/","link":"","permalink":"http://yoursite.com/2019/11/09/vue%E7%9A%84%E4%BC%98%E7%82%B9/","excerpt":"","text":"vue的优点1.轻量级的框架 只关注视图层，是一个构建数据的视图集合，大小只有几十kb 2.双向数据绑定3.组件化实现了html的封装和重用，在构建单页面应用方面有很大的优势 4.视图、数据、结构分离数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作 5.虚拟DOM不再使用原生的dom操作节点,极大解放dom操作,但具体操作的还是dom不过是换了另一种方式 6.各种指令;过滤器","categories":[],"tags":[]},{"title":"服务端渲染和浏览器端渲染的区别","slug":"服务器端渲染和客户端渲染","date":"2019-11-08T03:21:35.000Z","updated":"2019-11-08T03:21:38.857Z","comments":true,"path":"2019/11/08/服务器端渲染和客户端渲染/","link":"","permalink":"http://yoursite.com/2019/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/","excerpt":"","text":"服务端渲染和浏览器端渲染的区别服务器端渲染 在早期的时候，由于页面比较简单，前后端分离还没有做的比较完善，所以当时一般页面渲染还是在服务端完成html文件的拼装，然后浏览器接收到这个文件，就可以直接解析展示 客户端渲染伴随着ajax的兴起，使得现在越来越崇尚前后端分离的开 发方式。后端不再提供完整的html页面，而是提供一些API使得前端可以获取需要的json数据，然后前端拿到数据后在前端完成html页面的拼装，然后展示在浏览器上，这就是客户端渲染 了解三个专业名词 SPA：单页面应用，只有一张Web页面的应用，单页面跳转仅刷新局部资源，公共资源只需加载一次。 SEO：搜索引擎优化。应为SPA单页面应用的数据是通过Ajax来获取，难保证页面被搜索到，由此诞生了SSR SSR：服务端渲染，更快的响应时间，不用等待所有的js都下载完成，显示器便能显示出比较完整的页面；更好的SSR，我们可以将SEO关键信息直接在后台渲染成html，从而保证了搜索引擎可以提取到相应数据。 服务器端渲染的优缺点优点： 前端耗时少。后端拼接html 浏览器只需要渲染 有利于SEO。后端你有完整的html页面，爬虫更容易获取信息。 无需占用客户端资源。解析模板有后端来做，对于客户端的资源占用少，省电 后端生成静态化文件。即缓存片段，减少了类似页面的数据加载，加载页面更高效。缺点： 不利于前后端分离。开发效率低，对于前端复杂度高的项目，不利于项目的开发。后端任务繁重 占用服务器的资源。服务器完成html模板的解析，如果请求次数多对服务器造成一定的访问压力。 客户端渲染的优缺点优点： 前后端分离，前端专注于前端UI，后端专注于api开发，且前端有更多的选择性，而不需要遵循后端特定的模板。 体验更好。比如，我们将网站做成SPA或者部分内容做成SPA，这样，尤其是移动端，可以使体验更接近于原生app缺点： 前端响应较慢。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。 使用服务器渲染还是浏览器渲染还是要根据具体的实际情况进行选择，比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。","categories":[],"tags":[]},{"title":"string","slug":"string","date":"2019-11-06T08:30:59.418Z","updated":"2019-11-06T08:31:28.166Z","comments":true,"path":"2019/11/06/string/","link":"","permalink":"http://yoursite.com/2019/11/06/string/","excerpt":"","text":"#JS中常用的一些方法","categories":[],"tags":[]},{"title":"js数组的创建和常用的一些方法","slug":"js数组的创建和常用的一些方法","date":"2019-11-06T07:08:04.000Z","updated":"2019-11-08T08:44:27.208Z","comments":true,"path":"2019/11/06/js数组的创建和常用的一些方法/","link":"","permalink":"http://yoursite.com/2019/11/06/js%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"js数组的创建和常用的一些方法数组的概念 有序的元素序列 数组的创建方式 字面量创建数组 1234var arr = [1,2,3,4,5];console.log(arr.length);//获取数组长度console.log(arr[2]);//获取索引为2的数组元素arr[1] = 100;//修改数组中索引为1的数组元素 构造函数方式创建数组 1234//Array是一个构造函数，用来创建新的数组var arr = new Array(2); //当参数中只有个数字代表的是数组的长度；console.log(arr. length); //2console.log(arr[0]); //undefined Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）;数组中一些常用的方法1.pushpush 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）123456var arr = [];arr.push(1);//1 里面的参数是要添加的数组元素arr.push(&apos;aaa&apos;); // 2 arr.push(&#123;&#125;);console.log(arr); // [1,&apos;aaa&apos;,true,&#123;&#125;]console.log(arr.push(12)); //5 返回的是添加后的数组长度 2.poppop方法用于删除数组最后一个元素 ， 并返回该元素。（该方法会改变原数组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.pop() ；// &apos;c&apos; console.log(arr.pop()); // &apos;b&apos;console.log(arr); //[&apos;a&apos;] ==push和pop的结合的使用 构成了 ’后进先出‘ 的栈结构== 3.unshiftunshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.unshift(&apos;x&apos;); //4console.log(arr.unshift(&apos;y&apos;)); //5console.log(arr); //[&apos;y&apos;,&apos;x&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] 4.shiftshift方法用于删除数组的第一个元素，并返回该元素 。（该方法会改变原数组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.shift(); //&apos;a&apos;console.log(arr.shift());//&apos;b&apos;console.log(arr); //[&apos;c&apos;] 5.concatconcat方法用于合并数组（不会改变原数组）12345var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];var arr1 = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];console.log( arr.concat(arr1)); // 查看该方法的返回值 为一个新的数组 console.log(arr); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]console.log(arr1); // [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;] 6.sliceslice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）1234567var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];console.log(arr.slice())// [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]console.log(arr.slice(0)) // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]console.log(arr.slice(2,4))//[&apos;c&apos;,&apos;d&apos;] 从索引为2的元素复制到索引为4的元素（不包括此元素）console.log(arr.slice(4,2)); // [] 空数组console.log(arr.slice(2))// [&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] 从索引为2的元素到之后所有的元素console.log(arr.slice(-3,-1));ra//[&apos;c&apos;,&apos;d&apos;] 参数为负数则表示倒数的位置的元素 7.splicesplice方法用于删除原数组的一部分成员 并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素123var arr[1,2,3,4,5,6];arr.splice(1,3,7,8,9);console.log(arr); //[1,7,8,9,5,6] ==可以只删除不添加 第三个参数不写可以只添加不删除 第二个参数为0； 添加在第一个参数为索引的元素的前面== 8.reversereverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）123var arr = [1,2,3,4,5,6];arr.reverse();console.log(arr); //[6,5,4,3,2,1] 9.sortsort方法用于按一定的顺序排列数组元素 默认的顺序是按照字典排序 （会改变元素的顺序）12345678910111213var arr = [5,2,3,4,1,6];arr.sort();console.log(arr); //[1,2,3,4,5,6] 默认升序var arr = [5,2,3,4,1,12,24,6];arr.sort();console.log(arr);//[1,12,2,24,3,4,5,6]&lt;!--sort(); 内传入参数 可实现按数字大小排列--&gt;&lt;!-- 传入函数 function(a,b)&#123;--&gt;&lt;!-- return a-b; --&gt;&lt;!-- &#125; ///升序--&gt;&lt;!-- function(a,b)&#123;--&gt;&lt;!-- return b-a;--&gt;&lt;!-- &#125; ///降序--&gt; 10.joinjoin方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回 默认以逗号隔开1234var arr = [1,2,3,4,5,6];console.log( arr.join());// &apos;1,2,3,4,5,6&apos;console.log( arr.join(&apos;|&apos;));// &apos;1|2|3|4|5|6&apos;console.log( arr.join(&apos; &apos;)); // &apos;1 2 3 4 5 6&apos; ==如果数组元素是undefined或者null 或者空格 会被转成空字符串 console.log( [undefined, null,””].join(‘.’))== ES6中新增的数组的方法静态方法： Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足123var arr = [1,2,3];console.log(typeof arr);//objectconsole.log(Array.isArray(arr));//true mapmap方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）12345var num = [1,2,3,4]; var res = num.map(function(v)&#123; return v+1; //把每一个元素加1返回到新数组 &#125;); console.log(res); ==map方法接受一个函数作为参数 调用函数的时候 map方法向函数传入三个参数（当前元素，当前位置（下标），数组本身）== forEachforEach方法用于操作数组内的元素执行函数 和 map不一样的是 forEach方法不返回值 ，只用来操作数据。 使用方法一致 传入的参数一致 (不改变原数组)1234var arr = [1,2,3,4,5,6]; arr.forEach(function(v,i,a)&#123; console.log(&apos;[&apos;+i+&apos;]&apos;+&quot;=====&quot;+v); &#125;) ;// [0]=====1 [1]=====2... ==注意：forEach方法无法停止执行，总是会将所有元素遍历完，如果希望符合条件停止遍历请用for循环遍历== filterfilter方法用于过滤数组成员 满足条件的将会被添加到新数组作为返回值返回。filter 方法的参数是一个函数，所有数组成员依次执行该函数 返回结果为true 的组成新数组返回 （不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）12345var arr = [1,2,3,4,5,6]; var res = arr.filter(function(elem,index,arr)&#123; return index%2==0; //满足索引为偶数的元素组成一个新数组 &#125;); console.log(res);//[1,3,5] raduceraduce方法一次处理数组的每个元素，最终累计为一个值raduce方法：参数1是一个函数，该函数的参数有两个 累计变量 当前变量参数2是一个数字 ，为累计计算的起始值 不写默认为第一个元素为起始值1234var res = [1,2,3,4] console.log(res.reduce(function(a,b)&#123; return a+b; //返回的是累加的计算结果 &#125;)) ;//10 indexOfindexOf方法 返回给定元素在数组中的第一次出现的位置 ，如果没有就返回-1； 有两个参数 第一个是 查找的元素 第二个是 开始的位置123var arr = [1,2,3,4,5]; console.log(arr.indexOf(2)); //1 console.log(arr.indexOf(5)); //4 lastIndexOflaseIndexOf方法 返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1 indexOf 和 lastIndexOf 这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符 === 进行判断 而NaN===NaN 返回的是 false12var arr = [1,2,3,4,5,6]; console.log(arr.lastIndexOf(4,-2));//3 somesome方法 用于判断数组中是否有符合条件的元素 有一个则返回 true 全部不满足则返回 false1234var arr = [1,2,3,4,5,6]; console.log(arr.some(function(v,i,arr)&#123; return v&gt;3; &#125;));//true everyevery方法用于判断数组中元素是否全部符合条件 全部符合则返回 true 有一个不符合则返回 false1234567var arr = [1,2,3,4,5,6,7]; console.log(arr.every(function(v,i,arr)&#123; return v&gt;0;//ture &#125;)); console.log(arr.every(function(v,i,arr)&#123; return v&gt;5;//false &#125;)); findfind方法用于查找符合条件的第一个元素 返回这元素12345var arr = [1,2,3,4,5,6]; var res = arr.find(function(v,i,arr)&#123; return v &gt;2; &#125;); console.log(res);//3 findIndex()findIndex方法用于查找满足条件的第一个元素的下标1234var arr = [1,2,3,4,5,6]; console.log(arr.findIndex(function(v,i,arr)&#123; return v &gt; 3; &#125;));//3","categories":[],"tags":[]},{"title":"浏览器从输入url到页面显示内容的过程","slug":"浏览器从输入url到页面显示内容过程","date":"2019-11-06T07:08:04.000Z","updated":"2019-11-18T02:58:56.812Z","comments":true,"path":"2019/11/06/浏览器从输入url到页面显示内容过程/","link":"","permalink":"http://yoursite.com/2019/11/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9%E8%BF%87%E7%A8%8B/","excerpt":"","text":"浏览器从输入url到页面显示内容的过程在每次使用浏览器浏览页面时，输入url或者网址，然后浏览器就会渲染出对应的页面，中间包含的过程包括以下几步： 要解析域名转换成对应的公网IP 根据公网IP通过庞大的互联网路由到对应的服务器 建立可靠的TCP数据连接（TCP/IP 三次握手） 服务器对该URL中的请求数据进行分发处理，返回一个html 浏览器或者客户端对html进行渲染 1.域名解析首先，我们在浏览器中输入的其实是个域名，并不是一个可以再互联网中可以路由的公网IP地址，要将类似于Https://www.baidu.com 这样的域名解析为Ip地址，就需要依靠DNS服务了，DNS服务可以将该域名解析为IP地址。具体是通过DNS服务器提供的服务来完成的，DNS服务器上维护了一张映射表，key为域名，value为Ip地址。由于庞大的互联网对于解析域名的需求十分庞大，所以不可能只部署了一台域名解析服务器。现在的互联网是采用了树型的分层的分布式域名解析服务器集群来完成的。如果这一级的DNS服务器上找不到，则会进一步向上一级的DNS发去查询请求。直到根域名服务器为止。如果中间找到了对应的公网Ip，则再一级一级返回，如果找不到则返回错误信息。域名解析失败。 2.通过公网IP查找服务器有了公网IP地址，我们就可以通过路由器找到对应的服务器所在，并进一步进行通信。公网IP在整个互联网上是独一无二的，每个公网IP都代表着独立不同的节点、集群、或者服务。通过互联网间的路由器和路由表既可查找到对应的服务器。这部分我也不太熟悉，就不细细展开了。 3.建立TCP连接找到服务器后，就开始为通信做准备，通信协议在网络层主要有两种，一种是TCP、一种是UDP。而TCP可以通过可靠的网络通信服务，保证了通信双方的信息不丢失。 这里使用的TCP协议在使用前需要首先在客户端和服务端之间，建立起一条数据链路。分为三步，也叫作TCP三次握手。 3.1、TCP连接请求方，也就是客户端会发送一个请求建立连接的syn包（syn=x）给服务器； 3.2、服务器接受到建立连接的请求syn包后，会回复一个确认包。其中有参数ACK=x+1。同时它自己还会再发一个SYN包，这里的SYN=y； 3.3、客户端接收到服务器端发送来的确认建立连接请求的包后，再次回复一个确认包。这里的ACK=y+1；到了这里，客户端和服务端之间的链接就已经建立起来了。 4.服务器后端对URL进行处理分发这里主要是指客户端会根据URL携带的不同信息，对其进行分发和数据处理。通过对应的URL格式dispatch到不同的后台处理Java类中，进行数据处理后，再返回对应的HTML文件给客户端。 5.对HTML在客户端进行渲染现在的网页多是动态HTML。里面包含了大量的JS代码。目前的浏览器为了尽快加载页面，普遍采用了一遍解析一遍加载的原则。 6.扩展这里其实只是一个简单的过程分析，其实真正要去详细展开说明的话，会有很多的内容在其中，例如CDN加速、浏览器缓存、HTTPS中的证书CA认证、SSL、路由查找、后端分发、前端渲染等等等等。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"浅谈前端中的数据结构","slug":"浅谈前端中的数据结构","date":"2019-09-10T07:08:04.000Z","updated":"2019-11-22T11:32:17.968Z","comments":true,"path":"2019/09/10/浅谈前端中的数据结构/","link":"","permalink":"http://yoursite.com/2019/09/10/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"前端中的数据结构面向对象 讲js的数据结构，首先肯定要从面向对象开始讲。原因如下 编程虽然有很很多种语言，但他们也有共同的特性，最终都会进化成一个面向对象的语言。这是因为面向对象带给编程开发有很多的好处，解决编程时遇到的业务问题 在js中的面向对象，继承：需要依赖原型prototype。封装：需要依赖函数作用域和闭包。数据结构为其中隐藏的看不到的东西。今天来总结一下前端开发中的数据结构的认识。 堆（heap）、栈（stack） 说到堆栈，主要讲的就是内存的使用和分配。 各种语言在处理堆栈的问题上原理大同小异 堆是动态分配内存，内存大小不一，也不会自动释放，栈是自动分配相对固定大小的内存空间，并由系统自动释放. js的基本数据类型有5种 string 、number 、 boolean 、null 、undefined 。他们都是直接按值储存在栈中，大小确定，由系统自动分配和释放。好处是 内存可以及时得到回收，节约性能。 其次是js中的引用数据类型（对象、数组、函数），他们是通过拷贝或者new出来的，这样的数据储存在堆中。其实说储存在堆中也不是完全正确，引用类型的地址是储存在栈中的，当我们要访问堆中的数据，需要先从栈中获取到地址，地址指向的是堆中的数据。 两者对比 栈，线性结构，现进后出，便于管理。堆，一个混沌，杂乱无章，方便存储和开辟空间 传值与传址12345678910var aArray = [8,8, &quot;ass&quot;];var bArray = aArray ;var cString = aArray [2];alert(bArray);//88assalert(cString);//ass b[3] = 6;c = 7;alert(a[3]);//6alert(a[2]);//ass 上方例子得知，当我改变bArray中的数据时，aArray中数据也发生了变化，当改变cString的数据值时，aArray却没有发生改变。为什么？这就是传值与传址的区别。 因为aArray是数组，属于引用类型，所以它赋予给bArray的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。cString的到的是一个基本类型的赋值，因此，cString仅仅是从aArray堆内存中获取了一个数值，并直接保存在栈中。aArray、bArray都指向同一块堆内存，bArray修改的堆内存的时候，也就会影响到aArray，cString是直接在栈中修改，并且不能影响到aArray堆内存中的数据。 浅拷贝和深拷贝上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将aArray的每个基本类型的数据都遍历一遍，依次的赋值给bArray的对应字段。避免产生因为地址引用带来的问题。 数据结构 经典的数据结构大概就那么几种，list、stack、queue、linkedList、dictionary、hash、set、tree、graph…… 数组 数组是基础，然后为数组封装好一个List构造函数，增加长度、插入、删除、索引、遍历等工具接口，这样就构造了一个列表。 列表只适用于数据无存储顺序，并且也不需要快速查找的那种小数据，说白了就是给数组穿了件衣服。 栈（Stack），具有后进先出的特点（LIFO，last in first out），是一种高效的列表，只对栈顶的数据进行添加和删除 对栈的操作主要是压栈push和出栈并删除pop，还有peek方法，找到栈顶数据，并返回这个数据 队列（Queue），具有先进先出的特点，是只能在队首取出或者删除元素，在队尾插入元素的列表。 队列的用处很大，除了前边说的堆内存以外，还有消息队列，对队列的操作主要是入队（push）和出队（shift），还有front（读取队首数据）和back（读取队尾数据）。 链表如c++和java这样的语言，数组是静态的，效率很高，长度固定，但是，当数组满了之后，再向其中增加数据就非常困难了。js中的数据是个对象，数组是动态的，没有了长度的限制，但是，数组的索引下标需要在js语言内部转换为js对象的属性名，因此效率打了折扣。因此，在实际应用中，除了有随机访问的需求之外，其他情况都可以用链表替换数组。 单向链表数组元素靠他们的位置进行引用，链表元素则是靠相互之间的关系进行引用 链表是由一组节点组成的集合。每个节点都使用一个对象引用指向它的后继。指向另一个节点的引用叫做链。链表的头部是一个特殊的节点叫头节点，尾部一般是一个null节点。 对链表的操作为删除/插入节点 ，方法是改变前一个节点的指向，指向后一个节点，待删除节点指向null为删除，指向插入的节点，插入节点指向后一个节点为添加 用js来实现链表，需要有两个基本结构。Node 类用来表示节点，LinkedList 类提供了插入节点、删除节点、显示列表元素的方法，以及其他一些辅助方法。 字典及散列 js对象本身就具有字典的功能，往简单了讲，可以用object来模拟字典的实现。 散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下。散列表是将数据映射到散列上，但是，有的时候会产生数据碰撞，这个时候就需要用开链法、线性探测法进行碰撞的解决。 集合集合（set）是一种包含不同元素的数据结构。集合中的元素称为成员。集合最重要的特点是：一是集合的成员是无序的，二是集合中不允许相同成员存在 对集合的操作并集：将两个集合中的成员进行合并，得到一个新的集合交集：两个集合中共同存在的成员组成一个新的集合补集：属于一个集合而不属于另一个集合的成员组合的集合 树树是非线性的、分层储存的数据结构可用来储存文件系统或者有序列表。树都有一个根节点（root node），节点下面的节点称他为父节点，下面的节点为它的子节点二叉树上查找、添加、删除数据是非常快的，查找比链表要快的多，增加和删除比数组要快的多。这是为什么呢？ 二叉树左节点，右节点，左孩子，右孩子 二叉查找树较小的值保存在左节点 较大的值保存在右节点 查找效率非常的高 遍历二叉查找树 中序遍历按照节点上的键值，以升序访问bst上的所有节点先序遍历先访问根节点，然后以同样的方法访问左子树和右子树后序遍历先访问子节点，从左子树到右子树，再到根节点","categories":[{"name":"前端 WEB","slug":"前端-WEB","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-WEB/"}],"tags":[{"name":"js数据结构","slug":"js数据结构","permalink":"http://yoursite.com/tags/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"回流和重绘（Repaint ang Reflow）","slug":"回流和重绘","date":"2019-09-10T07:08:04.000Z","updated":"2019-11-15T00:57:13.916Z","comments":true,"path":"2019/09/10/回流和重绘/","link":"","permalink":"http://yoursite.com/2019/09/10/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"","text":"回流和重绘（Repaint ang Reflow）什么是回流当render tree中的一部分（或者全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流（Reflow）。每个页面至少回流一次，就是在页面第一次加载的时候。 在回流的过程中，浏览器会使渲染树种受到影响的部分失效，并重新构造这部分渲染树，完成回流之后，浏览器会重新绘制受到影响的部分到屏幕中，该过程为重绘。 什么是重绘（Repaint）当render tree 中的一些元素需要更新属性，而这些属性至少影响外观、风格，而不会影响布局的，则称之为重绘 二者的区别回流必将引起重绘，重绘不一定引起回流。比如：只有颜色改变的时候就只会发生重绘而不会发生回流。当页面布局和几何属性发生改变的时候就需要回流。比如添加或者删除可见的DOM元素，元素位置发生改变，元素尺寸发生改变，内容改变。 扩展从以上可以得知 回流比重绘的代价更大。 如何减少回流和重绘？减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有： 不要1个1个改变元素的样式属性，最好直接改变className，但className是预先定义好的样式，不是动态的，如果你要动态改变一些样式，则使用cssText来改变 让要操作的元素进行”离线处理”，处理完后一起更新，这里所谓的”离线处理”即让元素不存在于render tree中，比如：使用documentFragment或div等元素进行缓存操作，这个主要用于添加元素的时候，大家应该都用过，就是先把所有要添加到元素添加到1个div(这个div也是新加的)，最后才把这个div append到body中。先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。 3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，就先读取到变量中进行缓存，以后用的时候直接读取变量就可以了，见下面代码： 1234567891011121314// 别这样写for(循环) &#123; el.style.left = el.offsetLeft + 5 + &quot;px&quot;; el.style.top = el.offsetTop + 5 + &quot;px&quot;;&#125;// 这样写好点var left = el.offsetLeft,top = el.offsetTop,s = el.style;for(循环) &#123; left += 10; top += 10; s.left = left + &quot;px&quot;; s.top = top + &quot;px&quot;;&#125; 考虑你的操作会影响到rendertree中的多少节点以及影响的方式，影响越多，花费肯定就越多。比如现在很多人使用jquery的animate方法移动元素来展示一些动画效果，想想下面2种移动的方法：12345678// block1是position:absolute 定位的元素，它移动会影响到它父元素下的所有子元素。// 因为在它移动过程中，所有子元素需要判断block1的z-index是否在自己的上面，// 如果是在自己的上面,则需要重绘,这里不会引起回流$(&quot;#block1&quot;).animate(&#123;left:50&#125;);// block2是相对定位的元素,这个影响的元素与block1一样，但是因为block2非绝对定位// 而且改变的是marginLeft属性，所以这里每次改变不但会影响重绘，// 还会引起父元素及其下元素的回流$(&quot;#block2&quot;).animate(&#123;marginLeft:50&#125;);","categories":[{"name":"前端 WEB","slug":"前端-WEB","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-WEB/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Git本地常用命令常用命令","slug":"git常用命令","date":"2019-06-06T07:08:04.000Z","updated":"2019-11-14T06:21:21.975Z","comments":true,"path":"2019/06/06/git常用命令/","link":"","permalink":"http://yoursite.com/2019/06/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git本地常用命令常用命令1. 创建git库 git init #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库） 2. 注册git用户用于在团队合作开发中，表明代码作者。 1git config --global user.name XXX #用户名 1git config --global user.email XXX #用户邮箱 1git config --list #查看用户信息 注：加–global，全局设置。 3. 向git库添加修改123git add[path], #会把对应的目录或文件，添加到stage状态git add. #会把当前所有的untrack files和changed but not update添加到stage状态 4. 向版本库提交修改1git commit -m **** #提交修改，添加注释 5. 查看当前代码库状态1git status 6. 产看版本信息1git log 7. 查看指定版本信息1git show sdjf989526562 8. 撤销修改123git reset --head #回到原来编辑的地方git reset --head dadf153 #回到指定版本git reset HEAD^ 回退一个版本 9. 向远端库推送修改1git push origin 分支名 Git团队开发常用的操作指令1. 获取远端库项目1git clone/pull 2. 团队开发的基本流程（多分支合并一个分支）1234git add . #添加改动的文件git commit -m *** 提交到本地git pull --rebase #将本地项目与服务器项目合并git push # 推送到服务器 Git分支管理1. 建立分支1git branch AAA #建立分支AAA 2. 分支切换1git checkout AAA #切换分支AAA 3. 将分支与主分支合并12git checkout master #首先切换到主分支git merge AAA #将分支AAA与主分支合并 4. 当前分支查看123git branch #默认有master（也称为主枝）git branch -r #查看远端库分支git branch –a #查看当前所有分支（包括本地分支和远端库分支） 5. 删除分支1git branch -d AAA #删除分支AAA 6. 切下远端库A分支到本地A分支1git checkout -b A origin/A （若本地A分支不存在，则自动新建）","categories":[],"tags":[]},{"title":"React之diff算法","slug":"react中的diff算法","date":"2019-05-06T07:08:04.000Z","updated":"2019-11-16T03:38:28.264Z","comments":true,"path":"2019/05/06/react中的diff算法/","link":"","permalink":"http://yoursite.com/2019/05/06/react%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"React之diff算法diff算法的作用计算出virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面 传统diff算法通过循环递归对节点进行依次对比，算法复杂度达到O（n^3）,n是树的节点数 React的diff算法（1）什么是调和？ 将virtual DOM树转化成actual DOM树的最少操作的过程称为调和（2）什么是React diff算法 diff算法是调和的具体实现tree diffReact 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同层级内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。如果是跨层级的移动操作，如下图： 因此，当进行跨层级的移动操作，React并不是简单的进行移动，而是进行了删除和创建的操作，会影响到React性能。应该避免DOM节点的跨层级操作（ps：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过控制CSS来达到显示和隐藏，而不是真的添加或移除DOM节点） component diffReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效的 如果是同一类型的组件，按照原策略继续比较virtual DOM tree 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点 对于同一类型的组件，有可能其virtual DOM没有发生任何变化，如果能确切的知道这点则可以节省大量的diff元算时间，因此React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff如图:如果组件D和组件G类型不同，但是结构类似。这种情况下，因为类型不同，所以react会删除D，创建G。所以我们可以使用shouldComponentUpdate()返回false来终中断diff算法。这种情况下React diff会影响性能，通常这种情况也很少发生在开发过程中因此，在component diff阶段的主要优化策略就是使用shouldComponentUpdate()方法element diff当节点处于同一层级的时候，React diff提供了三种节点操作，分别是：‘INSERT_MARKUP’(插入)、’MOVE_EXISTING’(移动)、’REMOVE_NODE’(删除) INSERT_MARKUP,新的component类型不在老集合里，即是全新的节点，需要对新节点执行插入操作 MOVE_EXISTING,在老集合有新的component类型，且element是可更新的类型，generateComponentChildren 已调用receiveComponentm，在这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。 REMOVE_NODE, 老component类型，在新集合也有，但对应的element不同则不能直接复用和更新，需要执行删除操作，或者老component不在新的集合里的，也需要执行删除操作。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React从Flux到Redux，react-redux","slug":"React从Flux到Redux，react-redux","date":"2019-04-06T07:08:04.000Z","updated":"2019-11-24T01:41:53.710Z","comments":true,"path":"2019/04/06/React从Flux到Redux，react-redux/","link":"","permalink":"http://yoursite.com/2019/04/06/React%E4%BB%8EFlux%E5%88%B0Redux%EF%BC%8Creact-redux/","excerpt":"","text":"React框架本身只应用于View，如果基于MVC模式开发，还需要Model和Control层，这样就催生了Flux，而Redux是基于Flux理念的一种解决方式，而Redux不是专为React开发的他可以应用在任何框架，针对React工程可以使用react-redux帮助我们更快更便捷的搭建Redux工程。 FluxFlux是Facebook用来构建客户端Web应用的应用框架，它采用单项数据流 来组合React中的视图组件，不允许Model和Control互相引用。大体框架： 大概流程： View（视图）: View发出用户的Action Actions（动作）：驱动Dispatcher发动改变 Dispatcher（派发器）:负责分发动作（事件） Dispatcher收到Action，要求Store进行相应的更新 Store（数据层）:储存数据，处理数据 Store更新后 发出一个“change”事件 view收到“change”事件，更新页面 dispatch与actiondispatcher 是事件调度中心，flux模型的中枢枢纽，管理Flux应用中心的所有数据流。他本质上是Store的回调注册。每个Store注册他自己并提供一个回调函数，当Dispatcher响应Action时，通过已注册的回调函数，将Action提供的数据负载发送给应用中的所有Store。 12345678910111213141516import &#123;Dispatcher&#125; from &apos;flux&apos;import Store from &apos;./Store&apos;var Dispatch=new Dispatcher();Dispatch.register((action)=&gt;&#123; switch(action.actionType)&#123; case &apos;ADD&apos;: Store.add(action.text) Store.change() break; case &apos;DEL&apos;: Store.del(action.text) Store.change() break &#125;&#125;)export default Dispatch action123456789101112131415var Action=&#123; additem(msg)&#123; return&#123; actionType:&apos;ADD&apos;, //当前行为的类型 text:msg //行为所携带的数据 &#125; &#125;, delitem(msg1)&#123; return&#123; actionType:&apos;DEL&apos;, text:msg1 &#125; &#125;&#125;export default Action store负责封装应用的业务逻辑跟数据的交互 Store中包含应用所有的数据 Store是应用中唯一的数据发生变更的地方 Store中没有赋值接口—所有的数据变更都是有diapatcher发送到store，新的数据随着Store触发的change事件回传到view。Store对外只暴露getter，不允许提供setter，禁止在任何地方直接操作Store123456789101112131415161718192021import &#123;EventEmitter&#125; from &apos;events&apos;import assign from &apos;object-assign&apos;var Store = assign(&#123;&#125;,EventEmitter.prototype,&#123; Todos:[], add(msg)&#123; this.Todos.push(msg) &#125;, del(msg1)&#123; this.Todos.splice(msg1,1) &#125;, change()&#123; this.emit(&apos;change&apos;) &#125;, listenchange(callback)&#123; this.on(&apos;change&apos;,callback) &#125;, getall()&#123; return this.Todos &#125;&#125;)export default Store controller-viewcontroller-view可以理解成MVC中的controller，他一般由应用的顶层容器充当，负责从store中获取数据并将数据传递到子组件中。简单的应用一般只有一个controller-view，复杂的应用中也可以有多个。controller-view是应用中唯一可以操作state的地方（setStore()） viewview(UI组件)ui-component 职责单一只允许代用action触发事件，数据从由上层容器通过属性传递过来 Redux** redux工作流程：**View调用store.dispatch发起Action-&gt;store接受Action（action传入reducer函数，reducer函数返回一个新的state）-&gt;通知store.subscribe订阅的重新渲染函数 Redux和Flux的区别Redux和Flux很像。主要区别在于Flux有多个可以改变应用状态的store，他通过事件来触发这些变化。组件可以订阅这些事件来和当前状态同步 Redux没有派发器dispatcher，但在Flux中dispatcher被用来传递数据到注册的回调事件。另一个不同是Flux中有很多可用扩展，带来了矛盾和混乱 在redux当中只能定义一个可以更新状态的store flux可以定义多个仓库 redux把store和dispatcher合并。结构更加简单清晰 新增state，对状态的管理更加明确","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"认识前端路由","slug":"前端路由","date":"2019-03-10T12:08:04.000Z","updated":"2019-11-26T06:01:59.995Z","comments":true,"path":"2019/03/10/前端路由/","link":"","permalink":"http://yoursite.com/2019/03/10/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/","excerpt":"","text":"前端路由的认识一、 路由在前端开发中路由是非常重要的一环，那么路由是什么？从路由的功能上来说：路由就是随着浏览器地址栏的变化，呈现不同的页面。从路由的原理上来说：路由就是URL到函数的映射。 二、 后端路由后端路由又被称为服务器端路由，服务器在接收到客户端发来的HTTP请求，会根据请求中的url信息，来找到对应的映射函数并执行该函数，然后将函数的返回值发送给客户端。映射函数相对于静态资源服务器来说可能就是文件读取操作，对于动态资源，可能是数据库读取操作、也可能是数据的处理。 然后根据获得的数据在服务器端使用相应的模板来及来对页面进行渲染，再将渲染的结果返回给客户端。 好处：安全性好，易于SEO。 坏处：加大了服务器的压力，不利于用户体验，代码冗余。 三、前端路由对于前端路由来说，路由的映射函数就是进行一些DOM的显示和隐藏操作。在访问不同的路径时，显示不同的页面组件。前端路由主要有两种： hash history前端路由也有缺点：在浏览器中前进后退键会重新发送请求 来获取数据数据，没有合理的利用缓存。 hash模式路由早起的前端路由是通过location.hash来实现的。location.hash的值就是URl中#后面的值。hash有以下几个特性： URl中的hash只是客户端的一个状态，也就是说当向服务器发送请求的时候不会发送hash部分。 hash值的变化，都会在浏览的访问历史记录中增加一个记录。因我们能够通过浏览器的前进和回退按钮控制hash的切换。 我们可以使用hashChange事件来监听hash的变化 触发hash变化的方式也有两种一种是通过a标签，设置href属性，当用户点击a标签 URL会发生改变 触发hashChange事件另外一种就是直接使用javaScript来对location.hash进行赋值，从而改变URL触发hashchange事件。 History前面的hash模式虽然不错，但是使用时都会加上一个#，并不是很美观。到了HTML5提供了History API来实现URL的变化。用到的主要的两个API ：history.pushState()和history.replaceState()。这两个API可以在不进行刷新的情况下，操作浏览器的历史记录。唯一不同的是前者是新增一个浏览器记录，后者是直接替换当前的历史记录。此外两个API都接受三个参数： 1window.history.pushState(null,null,&quot;http://www.163.com&quot;) 三个参数分别是： 状态对象（state object）：一个javascript对象于用pushState()方法创建的新历史记录条目关联。无论何时用户导航创建的状态，会触发popState事件，并能在事件中使用该对象。 标题（title）：一般浏览器会忽略，最好传入null， 地址（URL）：就是需要新增的历史记录的地址，浏览器不会去直接加载改地址，但后面也可能会去尝试加载该地址。此外注意的是 传入的URL和当前的URL是同源的。 两种路由的对比 两种路实实现方式的对比：基于Hash路由实现，兼容性更好；基于history实现的路由更正式更美观，可以设置与当前URL同源的任意URL路径更加直观。 此外基于hash路由实现 不需要对服务器做改动，基于history API实现的路由需要对服务器做一些改动，需要对不同的路由进行相应的设置才行。 React-Router React-Router是与reac配合使用的路由库，也可提供多个包单独使用。 react-router提供路由的核心功能，react-router-dom基于react-router提供了在浏览器运行环境下的一些功能，例如Link组件和BrowserRouter组件。 在使用react-router编写路由的时候，与之前的静态路由不同，静态路由是声明在一起的，并在程序渲染前导入，react-router v4开始使用动态路由将路由声明变成react组件内容的一部分，像div一样，只有在应用程序渲染时才发生路由。 React-Router提供了三种类型的组件：router components路由器组件、route components路由组件、navigation components导航组件 三者都应该从react-router-dom导入。 router components路由器组件：对于web项目，react-router-dom提供了和路由。这两个路由都会为你创建一个专门的history对象， 使用环境的话：如果你有一个请求响应的服务器建议使用 如果只是静态资源的服务器的话使用. route components路由组件：路由匹配组件有和.Route的作用是在location和path属性匹配时在此处渲染react组件，通过component、render、和children三个属性来指向渲染组件，component属性通常指向一个现存的组件，render只有在需要传递参数给渲染组件时使用。Switch 不是必须的，用于将Route组件分组并选择一个与当地地址匹配的第一个Route。 navigation components 导航组件：有Link NavLink Redirect 三个组件用于导航， to属性指向导航地址。Redirect用于重定向 扩展： Router：所有路由器组件的公用底层实现，通常我们会使BrowserRouter等高级组件代替。 BrowserRouter：使用 HTML5 历史 API 记录（ pushState，replaceState 和 popstate 事件）的 使您的UI与URL保持同步。 Route：作用是在location和Route的path属性匹配时，在此处呈现UI。如有Route没有path会一直与它最近的父级匹配。 Switch：用于将Route或Redirect组件分组，选择第一个与地址匹配的Route渲染。 Link：提供可访问的导航，会在html中创建a标签。 match属性：match对象中包含了如何匹配URL的信息。 history属性：history对象实现对session历史的管理。 location属性：location属性代表应用程序现在在哪，你想去哪。 withRouter高阶组件：当路由渲染是，withRouter会将已更新的history、match和location属性传入被包裹的组件。match、history和location对象都会在渲染Route组件时传入component、render和children指向的组件。 标签: 前端, react","categories":[{"name":"前端 WEB","slug":"前端-WEB","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-WEB/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React生命周期函数","slug":"React生命周期函数","date":"2018-09-06T07:08:04.000Z","updated":"2019-11-28T01:32:59.257Z","comments":true,"path":"2018/09/06/React生命周期函数/","link":"","permalink":"http://yoursite.com/2018/09/06/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"React生命周期函数React生命周期函数： 组件加载之前，组件加载完成，组件更新数据，组件销毁，这些阶段触发的一系列的方法，就是生命周期函数。 组件加载的时候触发的生命周期函数：constructor、componentWillMount、render、componentDidMount（dom操作） 组件数据更新的时候触发的生命周期函数：shouldComponentUpdate 、 componentWillUpdate 、 render 、 componentDidUpdate 在父组件里面改变props传值的时候触发的生命周期函数：componentWillReceiveProps 组件销毁的时候触发的生命周期函数：componentWillUnmount React生命周期函数执行次数 只执行一次：constructor 、 componentWillMount 、 componentDidMount 执行多次： render 、 子组件的componentWillReceiveProps、componentWillUpdate、componentDidUpdate 有条件的执行 ：componentWillUnmount（页面离开，组件销毁） 不执行：根组件的componentWillReceiveProps React生命周期函数执行的顺序 如果不涉及setState更新，第一次渲染的顺序是：constructor — AppcomponentWillMount — Apprender — Appconstructor — parentcomponentWillMount — parentrender — parentconstructor — childcomponentDidMount — childrender — childcomponentDidMount — parentcomponentDidMount — App 如果涉及到触发App的setState事件componentWillUpdate — Apprender — AppcomponentWillReceiveProps — parentcomponentWillUpdate — parentrender — parentcomponentWillReceiveProps — childcomponentWillUpdate — childrender — childcomponentDidUpdate — childcomponentDidUpdate — parentcomponentDidUpdate — App 如果是触发parent的setState事件componentWillUpdate — parentrender — parentcomponentWillReceiveProps — childcomponentWillUpdate — childrender — childcomponentDidUpdate — childcomponentDidUpdate — parent 如果只是触发了child的setState事件componentWillUpdate — childrender — childcomponentDidUpdate — child结论 如图：完成前的顺序是从跟部到子部，完成时是从子部到根部。（类似于事件机制） 每个组件生命周期时都执行一遍完毕后在执行低一级的组件的生命周期函数 什么时候使用componentWillReceiveProps？ 大部分情况下并不会使用componentWillReceiveProps生命周期函数，可以省去。 但是在constructor函数中初始化了某个state，必须用componentWillReceiveProps来更新state，不可省去，否则render中的state将得不到更新。 使用componentWillReceiveProps的时候不要向上分发，调用父组件的相关setState方法否则会成为死循环. 最后附上React生命周期函数的官方解析： 1234567componentWillMount 在渲染之前调用，在客户端也在服务器端 componentDidMount 在第一次渲染之后调用。只在客户端，之后组件便生成了对应的DOM结构 compoentWillReceiveProps 在组件收到一个新的prop（更新后）被调用 。 这个方法在初始化render时不会被调用。 shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不会被调用 componentWillUpdate 在组件接收到新的props或者state但是还没有render的时候被调用，初始化时不会被调用 componentDidUpdate 在组建完成更新后立即被调用，初始化的时候不会被调用 componentDidMount 在组件从DOM中移除的时候立刻被调用","categories":[],"tags":[{"name":"前端 React","slug":"前端-React","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF-React/"}]},{"title":"React性能优化","slug":"React性能优化","date":"2018-09-06T07:08:04.000Z","updated":"2019-11-28T06:58:10.503Z","comments":true,"path":"2018/09/06/React性能优化/","link":"","permalink":"http://yoursite.com/2018/09/06/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"react 性能查看工具再讲性能优化之前，我们需要先来了解一下如何查看react加载组件时所耗费的时间的工具，在react 16版本之前我们可以使用React Perf来查看。 大家可以在chorme中先安装React Perf扩展，然后在入口文件或者redux的store.js中加入相应的代码即可： 在最新的React16版本中，我们可以直接在url后加上?react_pref，就可以在chrome浏览器的performance，我们可以查看User Timeing来查看组件的加载时间。 react性能优化之生命周期函数shouldComponentUpdatereact的父组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是有时候子组件接受父组件的数据没有发生变动。子组件render的执行会影响性能，这个时候可以使用shouldComponentUpdate来解决这个问题。 shouldComponentUpdate这是一个需要返回布尔值的生命周期函数，可以理解为组件本身需要重新渲染吗？例如： shouldComponentUpdate(){ if(子数据元数据 == 子数据现在接收到的数据){ return false; }else{ return true;; } }从而达到没有必要重新渲染的子组件，阻塞掉父组件render函数的执引起的子组件的render的重新渲染，提升性能。 单个组件的性能优化 render里面尽量减少新建变量的bind函数，传递参数时尽量减少传递参数的数量。","categories":[],"tags":[{"name":"前端 React  性能优化","slug":"前端-React-性能优化","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF-React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]}]}
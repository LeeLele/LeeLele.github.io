{"meta":{"title":"TL·Blog","subtitle":"[不积跬步无以至千里，不积小流无以成江海]","description":"","author":"李乐乐","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-08T03:30:33.000Z","updated":"2019-11-08T03:31:52.865Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-08T03:30:19.000Z","updated":"2019-11-08T03:32:03.273Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue和react的异同","slug":"vue和react的异同","date":"2019-11-10T07:08:04.000Z","updated":"2019-11-13T06:00:56.205Z","comments":true,"path":"2019/11/10/vue和react的异同/","link":"","permalink":"http://yoursite.com/2019/11/10/vue%E5%92%8Creact%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"vue和react的异同 vue和react都使用了 virtual DOM（虚拟DOM） vue和react都提供了组件化的视图组件 vue和react都将注意力集中保持在核心库，有丰富的插件库 react使用jsx渲染页面 ，vue使用更简单的模板 vue在运行速度上比react更快","categories":[],"tags":[]},{"title":"脱离脚手架使用webpack搭建React开发环境","slug":"脱离脚手架使用webpack搭建React开发环境","date":"2019-11-10T07:08:04.000Z","updated":"2019-11-13T05:59:31.299Z","comments":true,"path":"2019/11/10/脱离脚手架使用webpack搭建React开发环境/","link":"","permalink":"http://yoursite.com/2019/11/10/%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"脱离脚手架使用webpack搭建React开发环境使用前段构建工具webpack1. 实现模块化，代码整合，代码分割的作用 2. 整合之后不需要使用browser进行jsx转换js模块和模块化1.模块是指一组具有同等属性和功能的集合叫做模块，和类的概念相似 2.react模块化是指一个js存放一个或者多个组件，这些组件通过commonjs规范对外提供接口 3.在其他组件中调用这些对外提供的接口如何搭建开发环境 在文件目录下初始化一个项目 1npm init 安装所需项目依赖 (默认最高版本)1npm install webpack webpack-cli webpackk-dev-server react react-dom css-loader style-loader html-webpack-plugin --save-dev 构建文件目录 主文件index.html webpack.config.js配置文件 src(main .jscomponents views css js…) 配置webpack.config.js12345678910111213141516171819202122232425262728293031323334353637var webpack = require(&apos;webpack&apos;);var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)var path = require(&apos;path&apos;);module.exports = &#123; mode: &apos;production&apos;, //模式为生产模式 entry: &apos;./src/main.js&apos;, //入口文件 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].min.js&apos; //出口文件 &#125;, module: &#123; //模块 rules: [ //解析规则 &#123; test: /\\.css$/i, use: [&apos;style-loader&apos;, &apos;css-loader&apos;], &#125;, &#123; test:/\\.js$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ], &#125;, devServer: &#123; //热更新监听 contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 9000 &#125;, plugins:[ //打包复制主文件 new HtmlWebpackPlugin(&#123;template:&apos;./index.html&apos;&#125;), new webpack.HotModuleReplacementPlugin() ]&#125;; 配置main.js入口文件","categories":[],"tags":[]},{"title":"vue的优点","slug":"vue的优点","date":"2019-11-09T12:08:04.000Z","updated":"2019-11-09T12:52:20.380Z","comments":true,"path":"2019/11/09/vue的优点/","link":"","permalink":"http://yoursite.com/2019/11/09/vue%E7%9A%84%E4%BC%98%E7%82%B9/","excerpt":"","text":"vue的优点1.轻量级的框架 只关注视图层，是一个构建数据的视图集合，大小只有几十kb 2.双向数据绑定3.组件化实现了html的封装和重用，在构建单页面应用方面有很大的优势 4.视图、数据、结构分离数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作 5.虚拟DOM不再使用原生的dom操作节点,极大解放dom操作,但具体操作的还是dom不过是换了另一种方式 6.各种指令;过滤器","categories":[],"tags":[]},{"title":"服务端渲染和浏览器端渲染的区别","slug":"服务器端渲染和客户端渲染","date":"2019-11-08T03:21:35.000Z","updated":"2019-11-08T03:21:38.857Z","comments":true,"path":"2019/11/08/服务器端渲染和客户端渲染/","link":"","permalink":"http://yoursite.com/2019/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/","excerpt":"","text":"服务端渲染和浏览器端渲染的区别服务器端渲染 在早期的时候，由于页面比较简单，前后端分离还没有做的比较完善，所以当时一般页面渲染还是在服务端完成html文件的拼装，然后浏览器接收到这个文件，就可以直接解析展示 客户端渲染伴随着ajax的兴起，使得现在越来越崇尚前后端分离的开 发方式。后端不再提供完整的html页面，而是提供一些API使得前端可以获取需要的json数据，然后前端拿到数据后在前端完成html页面的拼装，然后展示在浏览器上，这就是客户端渲染 了解三个专业名词 SPA：单页面应用，只有一张Web页面的应用，单页面跳转仅刷新局部资源，公共资源只需加载一次。 SEO：搜索引擎优化。应为SPA单页面应用的数据是通过Ajax来获取，难保证页面被搜索到，由此诞生了SSR SSR：服务端渲染，更快的响应时间，不用等待所有的js都下载完成，显示器便能显示出比较完整的页面；更好的SSR，我们可以将SEO关键信息直接在后台渲染成html，从而保证了搜索引擎可以提取到相应数据。 服务器端渲染的优缺点优点： 前端耗时少。后端拼接html 浏览器只需要渲染 有利于SEO。后端你有完整的html页面，爬虫更容易获取信息。 无需占用客户端资源。解析模板有后端来做，对于客户端的资源占用少，省电 后端生成静态化文件。即缓存片段，减少了类似页面的数据加载，加载页面更高效。缺点： 不利于前后端分离。开发效率低，对于前端复杂度高的项目，不利于项目的开发。后端任务繁重 占用服务器的资源。服务器完成html模板的解析，如果请求次数多对服务器造成一定的访问压力。 客户端渲染的优缺点优点： 前后端分离，前端专注于前端UI，后端专注于api开发，且前端有更多的选择性，而不需要遵循后端特定的模板。 体验更好。比如，我们将网站做成SPA或者部分内容做成SPA，这样，尤其是移动端，可以使体验更接近于原生app缺点： 前端响应较慢。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。 使用服务器渲染还是浏览器渲染还是要根据具体的实际情况进行选择，比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。","categories":[],"tags":[]},{"title":"string","slug":"string","date":"2019-11-06T08:30:59.418Z","updated":"2019-11-06T08:31:28.166Z","comments":true,"path":"2019/11/06/string/","link":"","permalink":"http://yoursite.com/2019/11/06/string/","excerpt":"","text":"#JS中常用的一些方法","categories":[],"tags":[]},{"title":"js数组的创建和常用的一些方法","slug":"js数组的创建和常用的一些方法","date":"2019-11-06T07:08:04.000Z","updated":"2019-11-08T08:44:27.208Z","comments":true,"path":"2019/11/06/js数组的创建和常用的一些方法/","link":"","permalink":"http://yoursite.com/2019/11/06/js%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"js数组的创建和常用的一些方法数组的概念 有序的元素序列 数组的创建方式 字面量创建数组 1234var arr = [1,2,3,4,5];console.log(arr.length);//获取数组长度console.log(arr[2]);//获取索引为2的数组元素arr[1] = 100;//修改数组中索引为1的数组元素 构造函数方式创建数组 1234//Array是一个构造函数，用来创建新的数组var arr = new Array(2); //当参数中只有个数字代表的是数组的长度；console.log(arr. length); //2console.log(arr[0]); //undefined Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）;数组中一些常用的方法1.pushpush 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）123456var arr = [];arr.push(1);//1 里面的参数是要添加的数组元素arr.push(&apos;aaa&apos;); // 2 arr.push(&#123;&#125;);console.log(arr); // [1,&apos;aaa&apos;,true,&#123;&#125;]console.log(arr.push(12)); //5 返回的是添加后的数组长度 2.poppop方法用于删除数组最后一个元素 ， 并返回该元素。（该方法会改变原数组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.pop() ；// &apos;c&apos; console.log(arr.pop()); // &apos;b&apos;console.log(arr); //[&apos;a&apos;] ==push和pop的结合的使用 构成了 ’后进先出‘ 的栈结构== 3.unshiftunshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.unshift(&apos;x&apos;); //4console.log(arr.unshift(&apos;y&apos;)); //5console.log(arr); //[&apos;y&apos;,&apos;x&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] 4.shiftshift方法用于删除数组的第一个元素，并返回该元素 。（该方法会改变原数组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.shift(); //&apos;a&apos;console.log(arr.shift());//&apos;b&apos;console.log(arr); //[&apos;c&apos;] 5.concatconcat方法用于合并数组（不会改变原数组）12345var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];var arr1 = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];console.log( arr.concat(arr1)); // 查看该方法的返回值 为一个新的数组 console.log(arr); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]console.log(arr1); // [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;] 6.sliceslice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）1234567var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];console.log(arr.slice())// [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]console.log(arr.slice(0)) // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]console.log(arr.slice(2,4))//[&apos;c&apos;,&apos;d&apos;] 从索引为2的元素复制到索引为4的元素（不包括此元素）console.log(arr.slice(4,2)); // [] 空数组console.log(arr.slice(2))// [&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] 从索引为2的元素到之后所有的元素console.log(arr.slice(-3,-1));ra//[&apos;c&apos;,&apos;d&apos;] 参数为负数则表示倒数的位置的元素 7.splicesplice方法用于删除原数组的一部分成员 并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素123var arr[1,2,3,4,5,6];arr.splice(1,3,7,8,9);console.log(arr); //[1,7,8,9,5,6] ==可以只删除不添加 第三个参数不写可以只添加不删除 第二个参数为0； 添加在第一个参数为索引的元素的前面== 8.reversereverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）123var arr = [1,2,3,4,5,6];arr.reverse();console.log(arr); //[6,5,4,3,2,1] 9.sortsort方法用于按一定的顺序排列数组元素 默认的顺序是按照字典排序 （会改变元素的顺序）12345678910111213var arr = [5,2,3,4,1,6];arr.sort();console.log(arr); //[1,2,3,4,5,6] 默认升序var arr = [5,2,3,4,1,12,24,6];arr.sort();console.log(arr);//[1,12,2,24,3,4,5,6]&lt;!--sort(); 内传入参数 可实现按数字大小排列--&gt;&lt;!-- 传入函数 function(a,b)&#123;--&gt;&lt;!-- return a-b; --&gt;&lt;!-- &#125; ///升序--&gt;&lt;!-- function(a,b)&#123;--&gt;&lt;!-- return b-a;--&gt;&lt;!-- &#125; ///降序--&gt; 10.joinjoin方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回 默认以逗号隔开1234var arr = [1,2,3,4,5,6];console.log( arr.join());// &apos;1,2,3,4,5,6&apos;console.log( arr.join(&apos;|&apos;));// &apos;1|2|3|4|5|6&apos;console.log( arr.join(&apos; &apos;)); // &apos;1 2 3 4 5 6&apos; ==如果数组元素是undefined或者null 或者空格 会被转成空字符串 console.log( [undefined, null,””].join(‘.’))== ES6中新增的数组的方法静态方法： Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足123var arr = [1,2,3];console.log(typeof arr);//objectconsole.log(Array.isArray(arr));//true mapmap方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）12345var num = [1,2,3,4]; var res = num.map(function(v)&#123; return v+1; //把每一个元素加1返回到新数组 &#125;); console.log(res); ==map方法接受一个函数作为参数 调用函数的时候 map方法向函数传入三个参数（当前元素，当前位置（下标），数组本身）== forEachforEach方法用于操作数组内的元素执行函数 和 map不一样的是 forEach方法不返回值 ，只用来操作数据。 使用方法一致 传入的参数一致 (不改变原数组)1234var arr = [1,2,3,4,5,6]; arr.forEach(function(v,i,a)&#123; console.log(&apos;[&apos;+i+&apos;]&apos;+&quot;=====&quot;+v); &#125;) ;// [0]=====1 [1]=====2... ==注意：forEach方法无法停止执行，总是会将所有元素遍历完，如果希望符合条件停止遍历请用for循环遍历== filterfilter方法用于过滤数组成员 满足条件的将会被添加到新数组作为返回值返回。filter 方法的参数是一个函数，所有数组成员依次执行该函数 返回结果为true 的组成新数组返回 （不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）12345var arr = [1,2,3,4,5,6]; var res = arr.filter(function(elem,index,arr)&#123; return index%2==0; //满足索引为偶数的元素组成一个新数组 &#125;); console.log(res);//[1,3,5] raduceraduce方法一次处理数组的每个元素，最终累计为一个值raduce方法：参数1是一个函数，该函数的参数有两个 累计变量 当前变量参数2是一个数字 ，为累计计算的起始值 不写默认为第一个元素为起始值1234var res = [1,2,3,4] console.log(res.reduce(function(a,b)&#123; return a+b; //返回的是累加的计算结果 &#125;)) ;//10 indexOfindexOf方法 返回给定元素在数组中的第一次出现的位置 ，如果没有就返回-1； 有两个参数 第一个是 查找的元素 第二个是 开始的位置123var arr = [1,2,3,4,5]; console.log(arr.indexOf(2)); //1 console.log(arr.indexOf(5)); //4 lastIndexOflaseIndexOf方法 返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1 indexOf 和 lastIndexOf 这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符 === 进行判断 而NaN===NaN 返回的是 false12var arr = [1,2,3,4,5,6]; console.log(arr.lastIndexOf(4,-2));//3 somesome方法 用于判断数组中是否有符合条件的元素 有一个则返回 true 全部不满足则返回 false1234var arr = [1,2,3,4,5,6]; console.log(arr.some(function(v,i,arr)&#123; return v&gt;3; &#125;));//true everyevery方法用于判断数组中元素是否全部符合条件 全部符合则返回 true 有一个不符合则返回 false1234567var arr = [1,2,3,4,5,6,7]; console.log(arr.every(function(v,i,arr)&#123; return v&gt;0;//ture &#125;)); console.log(arr.every(function(v,i,arr)&#123; return v&gt;5;//false &#125;)); findfind方法用于查找符合条件的第一个元素 返回这元素12345var arr = [1,2,3,4,5,6]; var res = arr.find(function(v,i,arr)&#123; return v &gt;2; &#125;); console.log(res);//3 findIndex()findIndex方法用于查找满足条件的第一个元素的下标1234var arr = [1,2,3,4,5,6]; console.log(arr.findIndex(function(v,i,arr)&#123; return v &gt; 3; &#125;));//3","categories":[],"tags":[]}]}
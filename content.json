{"meta":{"title":"TL·Blog","subtitle":"[不积跬步无以至千里，不积小流无以成江海]","description":"","author":"李乐乐","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-08T03:30:33.000Z","updated":"2019-11-08T03:31:52.865Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-08T03:30:19.000Z","updated":"2019-11-08T03:32:03.273Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue和react的异同","slug":"vue和react的异同","date":"2019-11-10T07:08:04.000Z","updated":"2019-11-13T06:00:56.205Z","comments":true,"path":"2019/11/10/vue和react的异同/","link":"","permalink":"http://yoursite.com/2019/11/10/vue%E5%92%8Creact%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"vue和react的异同 vue和react都使用了 virtual DOM（虚拟DOM） vue和react都提供了组件化的视图组件 vue和react都将注意力集中保持在核心库，有丰富的插件库 react使用jsx渲染页面 ，vue使用更简单的模板 vue在运行速度上比react更快","categories":[],"tags":[]},{"title":"脱离脚手架使用webpack搭建React开发环境","slug":"脱离脚手架使用webpack搭建React开发环境","date":"2019-11-10T07:08:04.000Z","updated":"2019-11-16T03:38:40.376Z","comments":true,"path":"2019/11/10/脱离脚手架使用webpack搭建React开发环境/","link":"","permalink":"http://yoursite.com/2019/11/10/%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"脱离脚手架使用webpack搭建React开发环境使用前段构建工具webpack1. 实现模块化，代码整合，代码分割的作用 2. 整合之后不需要使用browser进行jsx转换js模块和模块化1.模块是指一组具有同等属性和功能的集合叫做模块，和类的概念相似 2.react模块化是指一个js存放一个或者多个组件，这些组件通过commonjs规范对外提供接口 3.在其他组件中调用这些对外提供的接口如何搭建开发环境 在文件目录下初始化一个项目 1npm init 安装所需项目依赖 (默认最高版本)1npm install webpack webpack-cli webpackk-dev-server react react-dom css-loader style-loader html-webpack-plugin --save-dev 构建文件目录 主文件index.html webpack.config.js配置文件 src(main .jscomponents views css js…) 配置webpack.config.js12345678910111213141516171819202122232425262728293031323334353637var webpack = require(&apos;webpack&apos;);var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)var path = require(&apos;path&apos;);module.exports = &#123; mode: &apos;production&apos;, //模式为生产模式 entry: &apos;./src/main.js&apos;, //入口文件 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].min.js&apos; //出口文件 &#125;, module: &#123; //模块 rules: [ //解析规则 &#123; test: /\\.css$/i, use: [&apos;style-loader&apos;, &apos;css-loader&apos;], &#125;, &#123; test:/\\.js$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ], &#125;, devServer: &#123; //热更新监听 contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 9000 &#125;, plugins:[ //打包复制主文件 new HtmlWebpackPlugin(&#123;template:&apos;./index.html&apos;&#125;), new webpack.HotModuleReplacementPlugin() ]&#125;; 配置main.js入口文件","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"vue的优点","slug":"vue的优点","date":"2019-11-09T12:08:04.000Z","updated":"2019-11-09T12:52:20.380Z","comments":true,"path":"2019/11/09/vue的优点/","link":"","permalink":"http://yoursite.com/2019/11/09/vue%E7%9A%84%E4%BC%98%E7%82%B9/","excerpt":"","text":"vue的优点1.轻量级的框架 只关注视图层，是一个构建数据的视图集合，大小只有几十kb 2.双向数据绑定3.组件化实现了html的封装和重用，在构建单页面应用方面有很大的优势 4.视图、数据、结构分离数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作 5.虚拟DOM不再使用原生的dom操作节点,极大解放dom操作,但具体操作的还是dom不过是换了另一种方式 6.各种指令;过滤器","categories":[],"tags":[]},{"title":"服务端渲染和浏览器端渲染的区别","slug":"服务器端渲染和客户端渲染","date":"2019-11-08T03:21:35.000Z","updated":"2019-11-08T03:21:38.857Z","comments":true,"path":"2019/11/08/服务器端渲染和客户端渲染/","link":"","permalink":"http://yoursite.com/2019/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/","excerpt":"","text":"服务端渲染和浏览器端渲染的区别服务器端渲染 在早期的时候，由于页面比较简单，前后端分离还没有做的比较完善，所以当时一般页面渲染还是在服务端完成html文件的拼装，然后浏览器接收到这个文件，就可以直接解析展示 客户端渲染伴随着ajax的兴起，使得现在越来越崇尚前后端分离的开 发方式。后端不再提供完整的html页面，而是提供一些API使得前端可以获取需要的json数据，然后前端拿到数据后在前端完成html页面的拼装，然后展示在浏览器上，这就是客户端渲染 了解三个专业名词 SPA：单页面应用，只有一张Web页面的应用，单页面跳转仅刷新局部资源，公共资源只需加载一次。 SEO：搜索引擎优化。应为SPA单页面应用的数据是通过Ajax来获取，难保证页面被搜索到，由此诞生了SSR SSR：服务端渲染，更快的响应时间，不用等待所有的js都下载完成，显示器便能显示出比较完整的页面；更好的SSR，我们可以将SEO关键信息直接在后台渲染成html，从而保证了搜索引擎可以提取到相应数据。 服务器端渲染的优缺点优点： 前端耗时少。后端拼接html 浏览器只需要渲染 有利于SEO。后端你有完整的html页面，爬虫更容易获取信息。 无需占用客户端资源。解析模板有后端来做，对于客户端的资源占用少，省电 后端生成静态化文件。即缓存片段，减少了类似页面的数据加载，加载页面更高效。缺点： 不利于前后端分离。开发效率低，对于前端复杂度高的项目，不利于项目的开发。后端任务繁重 占用服务器的资源。服务器完成html模板的解析，如果请求次数多对服务器造成一定的访问压力。 客户端渲染的优缺点优点： 前后端分离，前端专注于前端UI，后端专注于api开发，且前端有更多的选择性，而不需要遵循后端特定的模板。 体验更好。比如，我们将网站做成SPA或者部分内容做成SPA，这样，尤其是移动端，可以使体验更接近于原生app缺点： 前端响应较慢。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。 使用服务器渲染还是浏览器渲染还是要根据具体的实际情况进行选择，比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。","categories":[],"tags":[]},{"title":"string","slug":"string","date":"2019-11-06T08:30:59.418Z","updated":"2019-11-06T08:31:28.166Z","comments":true,"path":"2019/11/06/string/","link":"","permalink":"http://yoursite.com/2019/11/06/string/","excerpt":"","text":"#JS中常用的一些方法","categories":[],"tags":[]},{"title":"js数组的创建和常用的一些方法","slug":"js数组的创建和常用的一些方法","date":"2019-11-06T07:08:04.000Z","updated":"2019-11-08T08:44:27.208Z","comments":true,"path":"2019/11/06/js数组的创建和常用的一些方法/","link":"","permalink":"http://yoursite.com/2019/11/06/js%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"js数组的创建和常用的一些方法数组的概念 有序的元素序列 数组的创建方式 字面量创建数组 1234var arr = [1,2,3,4,5];console.log(arr.length);//获取数组长度console.log(arr[2]);//获取索引为2的数组元素arr[1] = 100;//修改数组中索引为1的数组元素 构造函数方式创建数组 1234//Array是一个构造函数，用来创建新的数组var arr = new Array(2); //当参数中只有个数字代表的是数组的长度；console.log(arr. length); //2console.log(arr[0]); //undefined Array构造函数创建数组有一个很大的缺陷，就是不同的参数，会导致创建行为不一致（不建议使用）;数组中一些常用的方法1.pushpush 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）123456var arr = [];arr.push(1);//1 里面的参数是要添加的数组元素arr.push(&apos;aaa&apos;); // 2 arr.push(&#123;&#125;);console.log(arr); // [1,&apos;aaa&apos;,true,&#123;&#125;]console.log(arr.push(12)); //5 返回的是添加后的数组长度 2.poppop方法用于删除数组最后一个元素 ， 并返回该元素。（该方法会改变原数组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.pop() ；// &apos;c&apos; console.log(arr.pop()); // &apos;b&apos;console.log(arr); //[&apos;a&apos;] ==push和pop的结合的使用 构成了 ’后进先出‘ 的栈结构== 3.unshiftunshift方法用于在数组的第一位置添加元素，并返回添加新元素后的数组长度（该方法会改变元素组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.unshift(&apos;x&apos;); //4console.log(arr.unshift(&apos;y&apos;)); //5console.log(arr); //[&apos;y&apos;,&apos;x&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] 4.shiftshift方法用于删除数组的第一个元素，并返回该元素 。（该方法会改变原数组）1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.shift(); //&apos;a&apos;console.log(arr.shift());//&apos;b&apos;console.log(arr); //[&apos;c&apos;] 5.concatconcat方法用于合并数组（不会改变原数组）12345var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];var arr1 = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];console.log( arr.concat(arr1)); // 查看该方法的返回值 为一个新的数组 console.log(arr); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]console.log(arr1); // [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;] 6.sliceslice方法用于复制目标数组的一部分，返回一个新的数组（不会改变原数组）1234567var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];console.log(arr.slice())// [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]console.log(arr.slice(0)) // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]console.log(arr.slice(2,4))//[&apos;c&apos;,&apos;d&apos;] 从索引为2的元素复制到索引为4的元素（不包括此元素）console.log(arr.slice(4,2)); // [] 空数组console.log(arr.slice(2))// [&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] 从索引为2的元素到之后所有的元素console.log(arr.slice(-3,-1));ra//[&apos;c&apos;,&apos;d&apos;] 参数为负数则表示倒数的位置的元素 7.splicesplice方法用于删除原数组的一部分成员 并可以在删除的位置的前面添加新的元素，返回一个数组为被删的元素组成（改变了原数组）splice第一个参数是删除的起始位置，第二个是被删除的个数，第三个和以后的参数是插入的元素123var arr[1,2,3,4,5,6];arr.splice(1,3,7,8,9);console.log(arr); //[1,7,8,9,5,6] ==可以只删除不添加 第三个参数不写可以只添加不删除 第二个参数为0； 添加在第一个参数为索引的元素的前面== 8.reversereverse方法用于颠覆排列数组元素，返回改变后的数组（会改变数组的原顺序）123var arr = [1,2,3,4,5,6];arr.reverse();console.log(arr); //[6,5,4,3,2,1] 9.sortsort方法用于按一定的顺序排列数组元素 默认的顺序是按照字典排序 （会改变元素的顺序）12345678910111213var arr = [5,2,3,4,1,6];arr.sort();console.log(arr); //[1,2,3,4,5,6] 默认升序var arr = [5,2,3,4,1,12,24,6];arr.sort();console.log(arr);//[1,12,2,24,3,4,5,6]&lt;!--sort(); 内传入参数 可实现按数字大小排列--&gt;&lt;!-- 传入函数 function(a,b)&#123;--&gt;&lt;!-- return a-b; --&gt;&lt;!-- &#125; ///升序--&gt;&lt;!-- function(a,b)&#123;--&gt;&lt;!-- return b-a;--&gt;&lt;!-- &#125; ///降序--&gt; 10.joinjoin方法用于指定参数作为分割符，将所有的元素连接为一个字符串返回 默认以逗号隔开1234var arr = [1,2,3,4,5,6];console.log( arr.join());// &apos;1,2,3,4,5,6&apos;console.log( arr.join(&apos;|&apos;));// &apos;1|2|3|4|5|6&apos;console.log( arr.join(&apos; &apos;)); // &apos;1 2 3 4 5 6&apos; ==如果数组元素是undefined或者null 或者空格 会被转成空字符串 console.log( [undefined, null,””].join(‘.’))== ES6中新增的数组的方法静态方法： Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。他可以弥补typeof运算符的不足123var arr = [1,2,3];console.log(typeof arr);//objectconsole.log(Array.isArray(arr));//true mapmap方法用于将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。（不改变原数组）12345var num = [1,2,3,4]; var res = num.map(function(v)&#123; return v+1; //把每一个元素加1返回到新数组 &#125;); console.log(res); ==map方法接受一个函数作为参数 调用函数的时候 map方法向函数传入三个参数（当前元素，当前位置（下标），数组本身）== forEachforEach方法用于操作数组内的元素执行函数 和 map不一样的是 forEach方法不返回值 ，只用来操作数据。 使用方法一致 传入的参数一致 (不改变原数组)1234var arr = [1,2,3,4,5,6]; arr.forEach(function(v,i,a)&#123; console.log(&apos;[&apos;+i+&apos;]&apos;+&quot;=====&quot;+v); &#125;) ;// [0]=====1 [1]=====2... ==注意：forEach方法无法停止执行，总是会将所有元素遍历完，如果希望符合条件停止遍历请用for循环遍历== filterfilter方法用于过滤数组成员 满足条件的将会被添加到新数组作为返回值返回。filter 方法的参数是一个函数，所有数组成员依次执行该函数 返回结果为true 的组成新数组返回 （不会改变原数组）该函数的参数为（当前成员，当前位置（索引），数组本身）12345var arr = [1,2,3,4,5,6]; var res = arr.filter(function(elem,index,arr)&#123; return index%2==0; //满足索引为偶数的元素组成一个新数组 &#125;); console.log(res);//[1,3,5] raduceraduce方法一次处理数组的每个元素，最终累计为一个值raduce方法：参数1是一个函数，该函数的参数有两个 累计变量 当前变量参数2是一个数字 ，为累计计算的起始值 不写默认为第一个元素为起始值1234var res = [1,2,3,4] console.log(res.reduce(function(a,b)&#123; return a+b; //返回的是累加的计算结果 &#125;)) ;//10 indexOfindexOf方法 返回给定元素在数组中的第一次出现的位置 ，如果没有就返回-1； 有两个参数 第一个是 查找的元素 第二个是 开始的位置123var arr = [1,2,3,4,5]; console.log(arr.indexOf(2)); //1 console.log(arr.indexOf(5)); //4 lastIndexOflaseIndexOf方法 返回的是给定元素在数组中的最后一次出现的位置，如果没有就返回-1 indexOf 和 lastIndexOf 这两个方法不能用来搜索NaN，因为这两个方法内部使用严格相等运算符 === 进行判断 而NaN===NaN 返回的是 false12var arr = [1,2,3,4,5,6]; console.log(arr.lastIndexOf(4,-2));//3 somesome方法 用于判断数组中是否有符合条件的元素 有一个则返回 true 全部不满足则返回 false1234var arr = [1,2,3,4,5,6]; console.log(arr.some(function(v,i,arr)&#123; return v&gt;3; &#125;));//true everyevery方法用于判断数组中元素是否全部符合条件 全部符合则返回 true 有一个不符合则返回 false1234567var arr = [1,2,3,4,5,6,7]; console.log(arr.every(function(v,i,arr)&#123; return v&gt;0;//ture &#125;)); console.log(arr.every(function(v,i,arr)&#123; return v&gt;5;//false &#125;)); findfind方法用于查找符合条件的第一个元素 返回这元素12345var arr = [1,2,3,4,5,6]; var res = arr.find(function(v,i,arr)&#123; return v &gt;2; &#125;); console.log(res);//3 findIndex()findIndex方法用于查找满足条件的第一个元素的下标1234var arr = [1,2,3,4,5,6]; console.log(arr.findIndex(function(v,i,arr)&#123; return v &gt; 3; &#125;));//3","categories":[],"tags":[]},{"title":"回流和重绘（Repaint ang Reflow）","slug":"回流和重绘","date":"2019-09-10T07:08:04.000Z","updated":"2019-11-15T00:57:13.916Z","comments":true,"path":"2019/09/10/回流和重绘/","link":"","permalink":"http://yoursite.com/2019/09/10/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"","text":"回流和重绘（Repaint ang Reflow）什么是回流当render tree中的一部分（或者全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流（Reflow）。每个页面至少回流一次，就是在页面第一次加载的时候。 在回流的过程中，浏览器会使渲染树种受到影响的部分失效，并重新构造这部分渲染树，完成回流之后，浏览器会重新绘制受到影响的部分到屏幕中，该过程为重绘。 什么是重绘（Repaint）当render tree 中的一些元素需要更新属性，而这些属性至少影响外观、风格，而不会影响布局的，则称之为重绘 二者的区别回流必将引起重绘，重绘不一定引起回流。比如：只有颜色改变的时候就只会发生重绘而不会发生回流。当页面布局和几何属性发生改变的时候就需要回流。比如添加或者删除可见的DOM元素，元素位置发生改变，元素尺寸发生改变，内容改变。 扩展从以上可以得知 回流比重绘的代价更大。 如何减少回流和重绘？减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有： 不要1个1个改变元素的样式属性，最好直接改变className，但className是预先定义好的样式，不是动态的，如果你要动态改变一些样式，则使用cssText来改变 让要操作的元素进行”离线处理”，处理完后一起更新，这里所谓的”离线处理”即让元素不存在于render tree中，比如：使用documentFragment或div等元素进行缓存操作，这个主要用于添加元素的时候，大家应该都用过，就是先把所有要添加到元素添加到1个div(这个div也是新加的)，最后才把这个div append到body中。先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。 3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，就先读取到变量中进行缓存，以后用的时候直接读取变量就可以了，见下面代码： 1234567891011121314// 别这样写for(循环) &#123; el.style.left = el.offsetLeft + 5 + &quot;px&quot;; el.style.top = el.offsetTop + 5 + &quot;px&quot;;&#125;// 这样写好点var left = el.offsetLeft,top = el.offsetTop,s = el.style;for(循环) &#123; left += 10; top += 10; s.left = left + &quot;px&quot;; s.top = top + &quot;px&quot;;&#125; 考虑你的操作会影响到rendertree中的多少节点以及影响的方式，影响越多，花费肯定就越多。比如现在很多人使用jquery的animate方法移动元素来展示一些动画效果，想想下面2种移动的方法：12345678// block1是position:absolute 定位的元素，它移动会影响到它父元素下的所有子元素。// 因为在它移动过程中，所有子元素需要判断block1的z-index是否在自己的上面，// 如果是在自己的上面,则需要重绘,这里不会引起回流$(&quot;#block1&quot;).animate(&#123;left:50&#125;);// block2是相对定位的元素,这个影响的元素与block1一样，但是因为block2非绝对定位// 而且改变的是marginLeft属性，所以这里每次改变不但会影响重绘，// 还会引起父元素及其下元素的回流$(&quot;#block2&quot;).animate(&#123;marginLeft:50&#125;);","categories":[{"name":"前端 WEB","slug":"前端-WEB","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-WEB/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Git本地常用命令常用命令","slug":"git常用命令","date":"2019-06-06T07:08:04.000Z","updated":"2019-11-14T06:21:21.975Z","comments":true,"path":"2019/06/06/git常用命令/","link":"","permalink":"http://yoursite.com/2019/06/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git本地常用命令常用命令1. 创建git库 git init #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库） 2. 注册git用户用于在团队合作开发中，表明代码作者。 1git config --global user.name XXX #用户名 1git config --global user.email XXX #用户邮箱 1git config --list #查看用户信息 注：加–global，全局设置。 3. 向git库添加修改123git add[path], #会把对应的目录或文件，添加到stage状态git add. #会把当前所有的untrack files和changed but not update添加到stage状态 4. 向版本库提交修改1git commit -m **** #提交修改，添加注释 5. 查看当前代码库状态1git status 6. 产看版本信息1git log 7. 查看指定版本信息1git show sdjf989526562 8. 撤销修改123git reset --head #回到原来编辑的地方git reset --head dadf153 #回到指定版本git reset HEAD^ 回退一个版本 9. 向远端库推送修改1git push origin 分支名 Git团队开发常用的操作指令1. 获取远端库项目1git clone/pull 2. 团队开发的基本流程（多分支合并一个分支）1234git add . #添加改动的文件git commit -m *** 提交到本地git pull --rebase #将本地项目与服务器项目合并git push # 推送到服务器 Git分支管理1. 建立分支1git branch AAA #建立分支AAA 2. 分支切换1git checkout AAA #切换分支AAA 3. 将分支与主分支合并12git checkout master #首先切换到主分支git merge AAA #将分支AAA与主分支合并 4. 当前分支查看123git branch #默认有master（也称为主枝）git branch -r #查看远端库分支git branch –a #查看当前所有分支（包括本地分支和远端库分支） 5. 删除分支1git branch -d AAA #删除分支AAA 6. 切下远端库A分支到本地A分支1git checkout -b A origin/A （若本地A分支不存在，则自动新建）","categories":[],"tags":[]},{"title":"React之diff算法","slug":"react中的diff算法","date":"2019-05-06T07:08:04.000Z","updated":"2019-11-16T03:38:28.264Z","comments":true,"path":"2019/05/06/react中的diff算法/","link":"","permalink":"http://yoursite.com/2019/05/06/react%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"React之diff算法diff算法的作用计算出virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面 传统diff算法通过循环递归对节点进行依次对比，算法复杂度达到O（n^3）,n是树的节点数 React的diff算法（1）什么是调和？ 将virtual DOM树转化成actual DOM树的最少操作的过程称为调和（2）什么是React diff算法 diff算法是调和的具体实现tree diffReact 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同层级内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。如果是跨层级的移动操作，如下图： 因此，当进行跨层级的移动操作，React并不是简单的进行移动，而是进行了删除和创建的操作，会影响到React性能。应该避免DOM节点的跨层级操作（ps：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过控制CSS来达到显示和隐藏，而不是真的添加或移除DOM节点） component diffReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效的 如果是同一类型的组件，按照原策略继续比较virtual DOM tree 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点 对于同一类型的组件，有可能其virtual DOM没有发生任何变化，如果能确切的知道这点则可以节省大量的diff元算时间，因此React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff如图:如果组件D和组件G类型不同，但是结构类似。这种情况下，因为类型不同，所以react会删除D，创建G。所以我们可以使用shouldComponentUpdate()返回false来终中断diff算法。这种情况下React diff会影响性能，通常这种情况也很少发生在开发过程中因此，在component diff阶段的主要优化策略就是使用shouldComponentUpdate()方法element diff当节点处于同一层级的时候，React diff提供了三种节点操作，分别是：‘INSERT_MARKUP’(插入)、’MOVE_EXISTING’(移动)、’REMOVE_NODE’(删除) INSERT_MARKUP,新的component类型不在老集合里，即是全新的节点，需要对新节点执行插入操作 MOVE_EXISTING,在老集合有新的component类型，且element是可更新的类型，generateComponentChildren 已调用receiveComponentm，在这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。 REMOVE_NODE, 老component类型，在新集合也有，但对应的element不同则不能直接复用和更新，需要执行删除操作，或者老component不在新的集合里的，也需要执行删除操作。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React从Flux到Redux，react-redux","slug":"React从Flux到Redux，react-redux","date":"2019-04-06T07:08:04.000Z","updated":"2019-11-18T02:32:45.149Z","comments":true,"path":"2019/04/06/React从Flux到Redux，react-redux/","link":"","permalink":"http://yoursite.com/2019/04/06/React%E4%BB%8EFlux%E5%88%B0Redux%EF%BC%8Creact-redux/","excerpt":"","text":"React框架本身只应用于View，如果基于MVC模式开发，还需要Model和Control层，这样就催生了Flux，而Redux是基于Flux理念的一种解决方式，而Redux不是专为React开发的他可以应用在任何框架，针对React工程可以使用react-redux帮助我们更快更便捷的搭建Redux工程。 FluxFlux是Facebook用来构建客户端Web应用的应用框架，它采用单项数据流 来组合React中的视图组件，不允许Model和Control互相引用。大体框架： 大概流程： View（视图）: View发出用户的Action Actions（动作）：驱动Dispatcher发动改变 Dispatcher（派发器）:负责分发动作（事件） Dispatcher收到Action，要求Store进行相应的更新 Store（数据层）:储存数据，处理数据 Store更新后 发出一个“change”事件 view收到“change”事件，更新页面 dispatch与actiondispatcher 是事件调度中心，flux模型的中枢枢纽，管理Flux应用中心的所有数据流。他本质上是Store的回调注册。每个Store注册他自己并提供一个回调函数，当Dispatcher响应Action时，通过已注册的回调函数，将Action提供的数据负载发送给应用中的所有Store。 12345678910111213141516import &#123;Dispatcher&#125; from &apos;flux&apos;import Store from &apos;./Store&apos;var Dispatch=new Dispatcher();Dispatch.register((action)=&gt;&#123; switch(action.actionType)&#123; case &apos;ADD&apos;: Store.add(action.text) Store.change() break; case &apos;DEL&apos;: Store.del(action.text) Store.change() break &#125;&#125;)export default Dispatch action123456789101112131415var Action=&#123; additem(msg)&#123; return&#123; actionType:&apos;ADD&apos;, //当前行为的类型 text:msg //行为所携带的数据 &#125; &#125;, delitem(msg1)&#123; return&#123; actionType:&apos;DEL&apos;, text:msg1 &#125; &#125;&#125;export default Action store负责封装应用的业务逻辑跟数据的交互 Store中包含应用所有的数据 Store是应用中唯一的数据发生变更的地方 Store中没有赋值接口—所有的数据变更都是有diapatcher发送到store，新的数据随着Store触发的change事件回传到view。Store对外只暴露getter，不允许提供setter，禁止在任何地方直接操作Store123456789101112131415161718192021import &#123;EventEmitter&#125; from &apos;events&apos;import assign from &apos;object-assign&apos;var Store = assign(&#123;&#125;,EventEmitter.prototype,&#123; Todos:[], add(msg)&#123; this.Todos.push(msg) &#125;, del(msg1)&#123; this.Todos.splice(msg1,1) &#125;, change()&#123; this.emit(&apos;change&apos;) &#125;, listenchange(callback)&#123; this.on(&apos;change&apos;,callback) &#125;, getall()&#123; return this.Todos &#125;&#125;)export default Store controller-viewcontroller-view可以理解成MVC中的controller，他一般由应用的顶层容器充当，负责从store中获取数据并将数据传递到子组件中。简单的应用一般只有一个controller-view，复杂的应用中也可以有多个。controller-view是应用中唯一可以操作state的地方（setStore()） viewview(UI组件)ui-component 职责单一只允许代用action触发事件，数据从由上层容器通过属性传递过来 Redux** redux工作流程：**View调用store.dispatch发起Action-&gt;store接受Action（action传入reducer函数，reducer函数返回一个新的state）-&gt;通知store.subscribe订阅的重新渲染函数 Redux和Flux的区别","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React从Flux到Redux，react-redux","slug":"浏览器从输入url到页面显示内容","date":"2019-04-06T07:08:04.000Z","updated":"2019-11-18T02:50:22.005Z","comments":true,"path":"2019/04/06/浏览器从输入url到页面显示内容/","link":"","permalink":"http://yoursite.com/2019/04/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9/","excerpt":"","text":"浏览器从输入url到页面显示内容的过程在每次使用浏览器浏览页面时，输入url或者网址，然后浏览器就会渲染出对应的页面，中间包含的过程包括以下几步： 要解析域名转换成对应的公网IP 根据公网IP通过庞大的互联网路由到对应的服务器 建立可靠的TCP数据连接（TCP/IP 三次握手） 服务器对该URL中的请求数据进行分发处理，返回一个html 浏览器或者客户端对html进行渲染 1.域名解析首先，我们在浏览器中输入的其实是个域名，并不是一个可以再互联网中可以路由的公网IP地址，要将类似于Https://www.baidu.com这样的域名解析为Ip地址，就需要依靠DNS服务了，DNS服务可以将该域名解析为IP地址。具体是通过DNS服务器提供的服务来完成的，DNS服务器上维护了一张映射表，key为域名，value为Ip地址。由于庞大的互联网对于解析域名的需求十分庞大，所以不可能只部署了一台域名解析服务器。现在的互联网是采用了树型的分层的分布式域名解析服务器集群来完成的。如果这一级的DNS服务器上找不到，则会进一步向上一级的DNS发去查询请求。直到根域名服务器为止。如果中间找到了对应的公网Ip，则再一级一级返回，如果找不到则返回错误信息。域名解析失败。 2.通过公网IP查找服务器有了公网IP地址，我们就可以通过路由器找到对应的服务器所在，并进一步进行通信。公网IP在整个互联网上是独一无二的，每个公网IP都代表着独立不同的节点、集群、或者服务。通过互联网间的路由器和路由表既可查找到对应的服务器。这部分我也不太熟悉，就不细细展开了。 3.建立TCP连接找到服务器后，就开始为通信做准备，通信协议在网络层主要有两种，一种是TCP、一种是UDP。而TCP可以通过可靠的网络通信服务，保证了通信双方的信息不丢失。 这里使用的TCP协议在使用前需要首先在客户端和服务端之间，建立起一条数据链路。分为三步，也叫作TCP三次握手。 3.1、TCP连接请求方，也就是客户端会发送一个请求建立连接的syn包（syn=x）给服务器； 3.2、服务器接受到建立连接的请求syn包后，会回复一个确认包。其中有参数ACK=x+1。同时它自己还会再发一个SYN包，这里的SYN=y； 3.3、客户端接收到服务器端发送来的确认建立连接请求的包后，再次回复一个确认包。这里的ACK=y+1；到了这里，客户端和服务端之间的链接就已经建立起来了。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]}]}